---
layout: post
title:  "魔术方法"
date:   2014-05-09 19:39:27 +0800
categories: jekyll update
---

__construct()，类的构造函数
 __destruct()，类的析构函数
__call()，在对象中调用一个不可访问方法时调用
 __callStatic()，用静态方式中调用一个不可访问方法时调用
 __get()，用静态方式中调用一个不可访问方法时调用
 __set()，设置一个类的成员变量时调用
 __isset()，当对不可访问属性调用isset()或empty()时调用
 __unset()，当对不可访问属性调用unset()时被调用。
_sleep()，执行serialize()时，先会调用这个函数
__wakeup()，执行unserialize()时，先会调用这个函数
__toString()，类被当成字符串时的回应方法
__invoke()，调用函数的方式调用一个对象时的回应方法
 __set_state()，调用var_export()导出类时，此静态方法会被调用
 __clone() ，当对象复制完成时调用
__debugInfo() ,是php5.6增加的特性，var_dump()一个类时的回应，返回一个包含对象属性的数组

等方法在 PHP 中被称为"魔术方法"（Magic methods）。在命名自己的类方法时不能使用这些方法名，除非是想使用其魔术功能。 
                                           



A：构造函数 __construct
        //该函数 为固定有的内容。当一个类实例化为对象时，如果要求随着对象的初始化要初始化一些成员（及也就是属性以及方法），那么就要在类中对该方法进行自定义编写修改 function __construct(形参列表){方法体}；
        //否则的话，在实例化为对象时，就执行一个默认的 空函数public function __construct(){}
        //Note: 如果子类中定义了构造函数则 不会 隐式调用其父类的构造函数。要执行父类的构造函数，需要在子类的构造函数中调用 parent::__construct()。 
        例：
            $obj=new class_name(实参列表);//触发 构造函数

B：析构函数 __destruct
    //有 多个指针的对象 无法直接销毁，必须在 直接关闭脚本或销毁全部指针 的情况下才会 析构该对象所占空间
        //该函数 为固定有的内容。当一个类实例化为对象时，如果要求随着对象的 销毁 要 运行 一些内容，那么就要在类中对该方法进行自定义编写修改；
        //否则的话，在 销毁 对象时，就执行一个默认行为的 函数public function __destruct(){}
        //和构造函数一样，父类的析构函数不会被引擎暗中调用。要执行父类的析构函数，必须在子类的析构函数体中显式调用 parent::__destruct()。 
        //析构函数即使在使用exit()终止脚本运行时也会被调用。在析构函数中 调用exit()将会中止其余关闭操作的运行。 
        //Note: 析构函数在脚本关闭时调用，此时所有的HTTP头信息已经发出。 脚本关闭时的工作目录有可能和在SAPI(如apache)中时不一样。 
        //Note: 试图在析构函数(在脚本终止时被调用)中抛出一个异常会导致致命错误。 
        例：
            $obj=new class_name(实参列表);
            unset($obj);

C：克隆函数：__clone
    //在多数情况下，我们并不需要完全复制一个对象来获得其中属性。但有一个情况下确实需要：如果你有一个 GTK窗口对象，该对象持有窗口相关的资源。你可能会想复制一个新的窗口，保持所有属性与原来的窗口相同， 但必须是一个新的对象（因为如果不是新的对象，那么一个窗口中的改变就会影响到另一个窗口）。还有一种情况： 如果对象A中保存着对象B的引用，当你复制对象A时，你想其中使用的对象不再是对象B而是B的一个副本，那么 你必须得到对象A的一个副本。 

    //对象复制可以通过clone关键字来完成（如果可能,这将调用对象的__clone()方法）。对象中的 __clone()方法不能被直接调用。 

    //默认地，用_clone()方法将建立一个与原对象拥有相同属性和方法的对象。_clone()可以没有参数，它自动包含$this和$that两个指针。需要注意的是，$this指向复本，而$that指向原本。

    //如果不需要克隆过来的默认行为，必须在基类中创建一个_clone()方法。这个方法类似于构造函数或析构函数，因为不会直接调用它。当以示例所示的方式使用clone关键字时，该方法将被调用。在_clone()方法中，可以定义所需要的确切复制行为。

    //在_clone()方法中添加的最常见的功能就是，确保作为引用进行处理的类属性能够正确地复制。如果要克隆一个包含有对象引用的类，可能需要获得该对象的第二个拷贝，而不是该对象的第二个引用。

    

        $copy_of_object = clone $object;


    //当对象被复制后，PHP5会对对象的所有属性执行一个浅复制（shallow copy）。所有的引用属性 仍然会是一个指向原来的变量的引用。 

    //当复制完成时, 如果定义了__clone()方法， 则新创建的对象（复制生成的对象）中的__clone()方法会被调用， 可用于修改属性的值（如果有必要的话）。 






1、__get、__set
这两个方法是为在类和他们的父类中没有声明的属性而设计的
__get( $property ) 当调用一个未定义的属性时访问此方法
__set( $property, $value ) 给一个未定义的属性赋值时调用
这里的没有声明包括当使用对象调用时，访问控制为proteced,private的属性（即没有权限访问的属性）

2、__isset、__unset
__isset( $property ) 当在一个未定义的属性上调用isset()函数时调用此方法
__unset( $property ) 当在一个未定义的属性上调用unset()函数时调用此方法
与__get方法和__set方法相同，这里的没有声明包括当使用对象调用时，访问控制为proteced,private的属性（即没有权限访问的属性）
3、__call
__call( $method, $arg_array ) 当调用一个未定义的方法是调用此访求
这里的未定义的方法包括没有权限访问的方法
4、__autoload
__autoload 函数，它会在试图使用尚未被定义的类时自动调用。通过调用此函数，脚本引擎在 PHP 出错失败前有了最后一个机会加载所需的类。
注意: 在 __autoload 函数中抛出的异常不能被 catch 语句块捕获并导致致命错误。
5、__construct、__destruct
__construct 构造方法，当一个对象创建时调用此方法，使用此方法的好处是：可以使构造方法有一个独一无二的名称,无论它所在的类的名称是什么.这样你在改变类的名称时,就不需要改变构造方法的名称
__destruct 析构方法，PHP将在对象被销毁前（即从内存中清除前）调用这个方法
默认情况下,PHP仅仅释放对象属性所占用的内存并销毁对象相关的资源.
析构函数允许你在使用一个对象之后执行任意代码来清除内存.
当PHP决定你的脚本不再与对象相关时,析构函数将被调用.
在一个函数的命名空间内,这会发生在函数return的时候.
对于全局变量,这发生于脚本结束的时候.如果你想明确地销毁一个对象,你可以给指向该对象的变量分配任何其它值.通常将变量赋值勤为NULL或者调用unset.

6、__clone
PHP5中的对象赋值是使用的引用赋值，如果想复制一个对
象则需要使用clone方法，在调用此方法是对象会自动调用__clone魔术方法
如果在对象复制需要执行某些初始化操作，可以在__clone方法实现

7、__toString
__toString方法在将一个对象转化成字符串时自动调用，比如使用echo打印对象时
如果类没有实现此方法，则无法通过echo打印对象，否则会显示：Catchable fatal error: Object of class test could not be converted to string in
此方法必须返回一个字符串
在PHP 5.2.0之前，__toString方法只有结合使用echo() 或 print()时 才能生效。PHP 5.2.0之后，则可以在任何字符串环境生效（例如通过printf()，使用%s修饰符），但 不能用于非字符串环境（如使用%d修饰符）。从PHP 5.2.0，如果将一个未定义__toString方法的对象 转换为字符串，会报出一个E_RECOVERABLE_ERROR错误。

8、__sleep、__wakeup
__sleep 串行化的时候用
__wakeup 反串行化的时候调用
serialize() 检查类中是否有魔术名称 __sleep 的函数。如果这样，该函数将在任何序列化之前运行。它可以清除对象并应该返回一个包含有该对象中应被序列化的所有变量名的数组。
使用 __sleep 的目的是关闭对象可能具有的任何数据库连接，提交等待中的数据或进行类似的清除任务。此外，如果有非常大的对象而并不需要完全储存下来时此函数也很有用。
相反地，unserialize() 检查具有魔术名称 __wakeup 的函数的存在。如果存在，此函数可以重建对象可能具有的任何资源。
使用 __wakeup 的目的是重建在序列化中可能丢失的任何数据库连接以及处理其它重新初始化的任务。

9、__set_state
当调用var_export()时，这个静态 方法会被调用（自PHP 5.1.0起有效）。
本方法的唯一参数是一个数组，其中包含按array(’property’ => value, …)格式排列的类属性。

10、__invoke
当尝试以调用函数的方式调用一个对象时，__invoke 方法会被自动调用。
PHP5.3.0以上版本有效
11、__callStatic
它的工作方式类似于 __call() 魔术方法，__callStatic() 是为了处理静态方法调用，
PHP5.3.0以上版本有效
PHP 确实加强了对 __callStatic() 方法的定义；它必须是公共的，并且必须被声明为静态的。同样，__call() 魔术方法必须被定义为公共的，所有其他魔术方法都必须如此。








[jekyll-docs]: http://jekyllrb.com/docs/home
[jekyll-gh]:   https://github.com/jekyll/jekyll
[jekyll-talk]: https://talk.jekyllrb.com/
