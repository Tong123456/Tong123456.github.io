<?xml version="1.0" encoding="utf-8"?><?xml-stylesheet type="text/xml" href="http://localhost:4000/feed.xslt.xml"?><feed xmlns="http://www.w3.org/2005/Atom"><generator uri="http://jekyllrb.com" version="3.3.0">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2016-11-17T08:56:55+08:00</updated><id>http://localhost:4000//</id><title type="html">Your awesome title</title><subtitle>Write an awesome description for your new site here. You can edit this line in _config.yml. It will appear in your document head meta (for Google search results) and in your feed.xml site description.
</subtitle><entry><title type="html">微信支付</title><link href="http://localhost:4000/jekyll/update/2016/11/05/%E5%BE%AE%E4%BF%A1%E6%94%AF%E4%BB%98.html" rel="alternate" type="text/html" title="微信支付" /><published>2016-11-05T08:22:35+08:00</published><updated>2016-11-05T08:22:35+08:00</updated><id>http://localhost:4000/jekyll/update/2016/11/05/%E5%BE%AE%E4%BF%A1%E6%94%AF%E4%BB%98</id><content type="html" xml:base="http://localhost:4000/jekyll/update/2016/11/05/%E5%BE%AE%E4%BF%A1%E6%94%AF%E4%BB%98.html">&lt;p&gt;支付模式&lt;/p&gt;

&lt;p&gt;刷卡支付：刷卡支付是用户展示微信钱包内的“刷卡条码/二维码”给商户系统扫描后直接完成支付的模式。主要应用线下面对面收银的场景。&lt;/p&gt;

&lt;p&gt;扫码支付：扫码支付是商户系统按微信支付协议生成支付二维码，用户再用微信“扫一扫”完成支付的模式。该模式适用于PC网站支付、实体店单品或订单支付、媒体广告支付等场景。&lt;/p&gt;

&lt;p&gt;公众号支付是用户在微信中打开商户的H5页面，商户在H5页面通过调用微信支付提供的JSAPI接口调起微信支付模块完成支付。应用场景有： 1) 用户在微信公众账号内进入商家公众号，打开某个主页面，完成支付 2) 用户的好友在朋友圈、聊天窗口等分享商家页面连接，用户点击链接打开商家页面，完成支付 3) 将商户页面转换成二维码，用户扫描二维码后在微信浏览器中打开页面后完成支付&lt;/p&gt;

&lt;p&gt;APP支付：APP支付又称移动端支付，是商户通过在移动端应用APP中集成开放SDK调起微信支付模块完成支付的模式。&lt;/p&gt;

&lt;p&gt;1.获取订单信息&lt;/p&gt;

&lt;p&gt;2.根据订单信息和支付相关的账号生成sign，并且生成支付参数&lt;/p&gt;

&lt;p&gt;3.将支付参数信息POST到微信服务器，获取返回信息&lt;/p&gt;

&lt;p&gt;4.根据返回信息生成相应的支付代码（微信内部）或是支付二维码（非微信内），完成支付。&lt;/p&gt;

&lt;p&gt;下面分步骤的讲一下：&lt;/p&gt;

&lt;p&gt;1.微信支付中相关的必须的订单参数有三个，分别是：body(商品名或订单描述),out_trade_no（一般为订单号）和total_fee（订单金额，单位“分”，要注意单位问题），在不同的应用中，首先要做的就是获取订单中的相关信息，为支付参数生成做准备。&lt;/p&gt;

&lt;p&gt;2.其他必须的支付参数有 appid（微信appid），mch_id（申请成功后告知）,device_info(web端和微信端该参数都是统一的，为大写的”WEB“)，trade_type（根据使用场景不同，该值也是不同的，微信外部为”NATIVE“，微信内部为”JSAPI“）,nonce_str(32位随机字符串),spbill_create_ip（发起支付的终端IP，即服务器IP），notify_url（支付回调地址，微信服务器通知网站支付完成与否，修改订单状态），sign（签名），还有一个需要说明的地方，如果trade_type为JSAPI的话，openid为必填的参数。&lt;/p&gt;

&lt;p&gt;签名算法是比较容易出错的地方，在于签名步骤繁琐，其实很关键的是，sign不参与签名&lt;/p&gt;

&lt;p&gt;A：将1、2中提到的除sign外的参数赋值，放到一个数组array里面，按照字典顺序排序，其实就是键值按照A—Z的顺序进行排序。&lt;/p&gt;

&lt;p&gt;B：将数组转换成字符串string，格式为 k1=v1&amp;amp;k2=v2&amp;amp;…kN=vN&lt;/p&gt;

&lt;p&gt;C：在此string后加上KEY值（在微信支付商户后台用户自己设定的）现在string = k1=v1&amp;amp;k2=v2&amp;amp;…kN=vN&amp;amp;key=KEY。&lt;/p&gt;

&lt;p&gt;D：string = md5(string)&lt;/p&gt;

&lt;p&gt;E: sign = strtoupper(string)&lt;/p&gt;

&lt;p&gt;至此，sign生成完毕。&lt;/p&gt;

&lt;p&gt;将sign添加到array数组里面生成新的数组。将该数组转换为XML。至此，微信支付的参数准备工作完成。&lt;/p&gt;

&lt;p&gt;3.将2中生成的XML，使用POST的方式发送请求到微信（https://api.mch.weixin.qq.com/pay/unifiedorder），获取返回的XML信息，将该信息转换成数组格式方便操作。返回的XML信息如下：&lt;/p&gt;

&lt;xml&gt;
   &lt;return_code&gt;&amp;lt;![CDATA[SUCCESS]]&amp;gt;&lt;/return_code&gt;
   &lt;return_msg&gt;&amp;lt;![CDATA[OK]]&amp;gt;&lt;/return_msg&gt;
   &lt;appid&gt;&amp;lt;![CDATA[wx2421b1c4370ec43b]]&amp;gt;&lt;/appid&gt;
   &lt;mch_id&gt;&amp;lt;![CDATA[10000100]]&amp;gt;&lt;/mch_id&gt;
   &lt;nonce_str&gt;&amp;lt;![CDATA[IITRi8Iabbblz1Jc]]&amp;gt;&lt;/nonce_str&gt;
   &lt;sign&gt;&amp;lt;![CDATA[7921E432F65EB8ED0CE9755F0E86D72F]]&amp;gt;&lt;/sign&gt;
   &lt;result_code&gt;&amp;lt;![CDATA[SUCCESS]]&amp;gt;&lt;/result_code&gt;
   &lt;prepay_id&gt;&amp;lt;![CDATA[wx201411101639507cbf6ffd8b0779950874]]&amp;gt;&lt;/prepay_id&gt;
   &lt;trade_type&gt;&amp;lt;![CDATA[JSAPI]]&amp;gt;&lt;/trade_type&gt;
&lt;/xml&gt;

&lt;p&gt;如果是trade_type==native支付的话，还会多一个参数code_url，该URL为微信扫码支付的地址。&lt;/p&gt;

&lt;p&gt;4.下面就是支付的过程了。&lt;/p&gt;

&lt;p&gt;如果trade_type==native，那么使用一些方式将code_url转换成二维码，使用微信扫码就可以了，如果是微信内部点击支付的话，需要调用微信js-sdk中的相关东西，这一步中最关键是生成一个json格式的字符串。&lt;/p&gt;

&lt;p&gt;首先要生成转换json字符串的数组array_jsapi。&lt;/p&gt;

&lt;p&gt;A：该数组的参数包括：appId，timeStamp,nonceStr,package,signType(默认为”MD5“)，要注意大小写和上面的数组里面是不一样的。&lt;/p&gt;

&lt;p&gt;B：使用该数组生成paySign参数，签名方式同上。&lt;/p&gt;

&lt;p&gt;C：将paySign参数追加到array_jsapi数组中。&lt;/p&gt;

&lt;p&gt;D：将该数组使用json_encode格式化为字符串js_string。&lt;/p&gt;

&lt;p&gt;完成上面的工作，就可以在微信内部进行支付了。&lt;/p&gt;

&lt;p&gt;下面为相关支付的示例代码：&lt;/p&gt;

&lt;script type=&quot;text/javascript&quot;&gt;
                    function jsApiCall()
    {
       WeixinJSBridge.invoke(
        'getBrandWCPayRequest',
        $js_string,
        function(res){
            WeixinJSBridge.log(res.err_msg);
                if(res.err_msg=='get_brand_wcpay_request:ok')
                {
                    alert('支付成功');
                }
                else
                {
                    alert('支付失败');
                }
            }
        );
    }
    function callpay()
    {
        if (typeof WeixinJSBridge == 'undefined'){
            if( document.addEventListener ){
                document.addEventListener('WeixinJSBridgeReady', jsApiCall, false);
            }else if (document.attachEvent){
                document.attachEvent('WeixinJSBridgeReady', jsApiCall);
                document.attachEvent('onWeixinJSBridgeReady', jsApiCall);
            }
        }else{
            jsApiCall();
        }
    }
&lt;/script&gt;

&lt;p&gt;代码中js_string即为我们生成的字符串。&lt;/p&gt;

&lt;p&gt;HTML代码中调用callpay()函数发起支付。&lt;/p&gt;

&lt;p&gt;这样微信支付的支付工作就完成了。&lt;/p&gt;

&lt;p&gt;下面是回调工作，该功能确保订单支付成功后，有正确的状态显示给用户。&lt;/p&gt;

&lt;p&gt;支付完成后，微信使用POST请求，将支付结果反馈给网站服务器，网站服务器获取POST信息，根据支付成功与否，来确定是否修改订单信息。&lt;/p&gt;

&lt;p&gt;A：将POST参数中的sign去除，并且记录下来该值。&lt;/p&gt;

&lt;p&gt;B：对剩余的参数进行签名&lt;/p&gt;

&lt;p&gt;C：将签名结果和POST中的sign进行比对，相同说明签名正确，根据支付结果修改订单状态。&lt;/p&gt;

&lt;p&gt;E：返回XML信息给微信，确保微信知道网站已经收到该通知，避免微信再次推送POST，示例如下：&lt;/p&gt;

&lt;xml&gt;
  &lt;return_code&gt;&amp;lt;![CDATA[SUCCESS]]&amp;gt;&lt;/return_code&gt;
  &lt;return_msg&gt;&amp;lt;![CDATA[OK]]&amp;gt;&lt;/return_msg&gt;
&lt;/xml&gt;

&lt;p&gt;如果失败，则返回&lt;/p&gt;

&lt;xml&gt;
  &lt;return_code&gt;&amp;lt;![CDATA[FAIL]]&amp;gt;&lt;/return_code&gt;
  &lt;return_msg&gt;&amp;lt;![CDATA[失败原因]]&amp;gt;&lt;/return_msg&gt;
&lt;/xml&gt;</content><summary type="html">支付模式</summary></entry><entry><title type="html">php-one</title><link href="http://localhost:4000/jekyll/update/2016/10/31/php-one.html" rel="alternate" type="text/html" title="php-one" /><published>2016-10-31T09:19:35+08:00</published><updated>2016-10-31T09:19:35+08:00</updated><id>http://localhost:4000/jekyll/update/2016/10/31/php-one</id><content type="html" xml:base="http://localhost:4000/jekyll/update/2016/10/31/php-one.html">&lt;p&gt;1：PHP使用PDO操作数据库&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;PDO扩展为PHP访问数据库定义了一个轻量级的、一致性的接口，它提供了一个数据访问抽象层，
这样，无论使用什么数据库，都可以通过一致的函数执行查询和获取数据。

PDO支持的PHP版本为PHP5.1以及更高的版本,而且在PHP5.2下PDO默认为开启状态,
下面是在php.ini中PDO的配置:

extension=php_pdo.dll

为了启用对某个数据库的支持,需要在php配置文件中将相应的扩展打开,例如要支持MySQL,需要开启下面的扩展

extension=php_pdo_mysql.dll

   &amp;lt;?php
     header(&quot;content-type:text/html;charset=utf-8&quot;);

$dsn=&quot;mysql:dbname=test;host=localhost&quot;;
$db_user='root';
$db_pass='admin';

try{
 $pdo=new PDO($dsn,$db_user,$db_pass);
}catch(PDOException $e){
 echo '数据库连接失败'.$e-&amp;gt;getMessage();
}

//新增
$sql=&quot;insert into buyer (username,password,email) values ('ff','123456','admin@admin.com')&quot;;
$res=$pdo-&amp;gt;exec($sql);
echo '影响行数：'.$res;


//修改
$sql=&quot;update buyer set username='ff123' where id&amp;gt;3&quot;;
$res=$pdo-&amp;gt;exec($sql);
echo '影响行数：'.$res;

//查询
$sql=&quot;select * from buyer&quot;;
$res=$pdo-&amp;gt;query($sql);

foreach($res as $row){
 echo $row['username'].'&amp;lt;br/&amp;gt;';
}

//删除
$sql=&quot;delete from buyer where id&amp;gt;5&quot;;
$res=$pdo-&amp;gt;exec($sql);
echo '影响行数：'.$res;
   ?&amp;gt;

 PDO 是基于向对象方式，那么错误处理也最好使用面向对象的方式来处理。在 PDOException 中定义了如下方法用于捕获错误信息：

方法 	说明
getMessage() 	取得文本化的错误信息
getCode() 	取得 SQLSTATE 错误代号
getFile() 	取得发生异常的文件名
getLine() 	取得 PHP 程序产生异常的代码所在行号
getTrace() 	backtrace() 数组
getTraceAsString() 	取得已格成化成字符串的 getTrace() 信息
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;二:数据库命令行
	（1）运行命令行
	（2）进入到MySQL路径下，然后输入mysql -u  user -p
	（3）选择数据库 use test
	（4）检查它是最近版本 mysql \r
	好了，现在你已经连接到test db，接下来你就可以执行SQL语句了。&lt;/p&gt;

&lt;p&gt;三:搜索词高亮显示
  将sql语句中包含的%$info%交给DBMS执行的时候，他会查找字段中含有变量$info的值的信息，&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;%$info---&amp;gt;查找以$info的值结束的信息

$info%---&amp;gt;查找以$info的值开头的信息

通过正则函数preg_replace()将搜索到的关键字高亮显示，比如，
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;　　　 $row[‘name’]=preg_replace(“/($info)/i”,”&amp;lt;b style=&quot;color:red&quot;&amp;gt;\1&amp;lt;/b&amp;gt;”,$row[‘name’]);&lt;/p&gt;

&lt;p&gt;　　　 的意思是：通过POST方接收到的值$info替换为加上样式（红色加粗）的结果，并将结果重新赋给$row[‘name’]&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;如果要搜索多个关键字的话，可以对接收到值$info进行分割，比如$info_more=explode(&quot; &quot;,$info);//这种方式能对以空格隔开的关键字进行分割，再对分割后的结果挨个进行查询，同样，可以使用正则表达式函数进行替换工作，以高亮显示关键字
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;</content><summary type="html">1：PHP使用PDO操作数据库</summary></entry><entry><title type="html">php-two</title><link href="http://localhost:4000/jekyll/update/2016/10/31/php-two.html" rel="alternate" type="text/html" title="php-two" /><published>2016-10-31T08:19:35+08:00</published><updated>2016-10-31T08:19:35+08:00</updated><id>http://localhost:4000/jekyll/update/2016/10/31/php-two</id><content type="html" xml:base="http://localhost:4000/jekyll/update/2016/10/31/php-two.html">&lt;p&gt;一：：session和cookie
	二者的定义：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;当你在浏览网站的时候，WEB 服务器会先送一小小资料放在你的计算机上，Cookie 会帮你在网站上所打的文字或是一些选择，

都纪录下来。当下次你再光临同一个网站，WEB 服务器会先看看有没有它上次留下的 Cookie 资料，有的话，就会依据 Cookie

里的内容来判断使用者，送出特定的网页内容给你。 Cookie 的使用很普遍，许多有提供个人化服务的网站，都是利用 Cookie

来辨认使用者，以方便送出使用者量身定做的内容，像是 Web 接口的免费 email 网站，都要用到 Cookie。


具体来说cookie机制采用的是在客户端保持状态的方案，而session机制采用的是在服务器端保持状态的方案。

同时我们也看到，由于采用服务器端保持状态的方案在客户端也需要保存一个标识，所以session机制可能需要借助于cookie机制

来达到保存标识的目的，但实际上它还有其他选择。

cookie机制。正统的cookie分发是通过扩展HTTP协议来实现的，服务器通过在HTTP的响应头中加上一行特殊的指示以提示

浏览器按照指示生成相应的cookie。然而纯粹的客户端脚本如JavaScript或者VBScript也可以生成cookie。而cookie的使用

是由浏览器按照一定的原则在后台自动发送给服务器的。浏览器检查所有存储的cookie，如果某个cookie所声明的作用范围

大于等于将要请求的资源所在的位置，则把该cookie附在请求资源的HTTP请求头上发送给服务器。
 
cookie的内容主要包括：名字，值，过期时间，路径和域。路径与域一起构成cookie的作用范围。若不设置过期时间，则表示这

个cookie的生命期为浏览器会话期间，关闭浏览器窗口，cookie就消失。这种生命期为浏览器会话期的cookie被称为会话cookie。

会话cookie一般不存储在硬盘上而是保存在内存里，当然这种行为并不是规范规定的。若设置了过期时间，浏览器就会把cookie

保存到硬盘上，关闭后再次打开浏览器，这些cookie仍然有效直到超过设定的过期时间。存储在硬盘上的cookie可以在不同的浏

览器进程间共享，比如两个IE窗口。而对于保存在内存里的cookie，不同的浏览器有不同的处理方式

session机制。session机制是一种服务器端的机制，服务器使用一种类似于散列表的结构（也可能就是使用散列表）来保存信息。

	  当程序需要为某个客户端的请求创建一个session时，服务器首先检查这个客户端的请求里是否已包含了一个session标识

（称为session id），如果已包含则说明以前已经为此客户端创建过session，服务器就按照session id把这个session检索出来

使用（检索不到，会新建一个），如果客户端请求不包含session id，则为此客户端创建一个session并且生成一个与此session相

关联的session id，session id的值应该是一个既不会重复，又不容易被找到规律以仿造的字符串，这个session id将被在本次响应

中返回给客户端保存。保存这个session id的方式可以采用cookie，这样在交互过程中浏览器可以自动的按照规则把这个标识发送给

服务器。一般这个cookie的名字都是类似于SEEESIONID。但cookie可以被人为的禁止，则必须有其他机制以便在cookie被禁止时

仍然能够把session id传递回服务器。

经常被使用的一种技术叫做URL重写，就是把session id直接附加在URL路径的后面。还有一种技术叫做表单隐藏字段。就是服务器

会自动修改表单，添加一个隐藏字段，以便在表单提交时能够把session id传递回服务器。比如：
&amp;lt;form name=&quot;testform&quot; action=&quot;/xxx&quot;&amp;gt;
&amp;lt;input type=&quot;hidden&quot; name=&quot;jsessionid&quot; value=&quot;ByOK3vjFD75aPnrF7C2HmdnV6QZcEbzWoWiBYEnLerjQ99zWpBng!-145788764&quot;&amp;gt;
&amp;lt;input type=&quot;text&quot;&amp;gt;
&amp;lt;/form&amp;gt;
实际上这种技术可以简单的用对action应用URL重写来代替。

cookie 和session 的区别：

1、cookie数据存放在客户的浏览器上，session数据放在服务器上。

2、cookie不是很安全，别人可以分析存放在本地的COOKIE并进行COOKIE欺骗
   考虑到安全应当使用session。

3、session会在一定时间内保存在服务器上。当访问增多，会比较占用你服务器的性能
   考虑到减轻服务器性能方面，应当使用COOKIE。

4、单个cookie保存的数据不能超过4K，很多浏览器都限制一个站点最多保存20个cookie。

5、所以个人建议：
   将登陆信息等重要信息存放为SESSION
   其他信息如果需要保留，可以放在COOKIE中

二：PHP部分函数
    

    php_strip_whitespace （参数1个php文件的路径）

        — 返回删除注释和空格后的PHP源码，返回删除注释和空格后 filename 的PHP源码。

        这对实际代码数量和注释数量的对比很有用。 此函数与 命令行 下执行 php -w 相似。

    var_export（参数1传入的字符串，参数2是否为true） — 输出或返回一个变量的字符串表示

        将函数的第二个参数设置为      TRUE，从而返回变量的表示。 

    token_get_all($source一个参数，为php源代码或者是文件中的内容)

        将提供的源码按 PHP 标记进行分割

        分割时会多出引号

    base64_encode （string $data,一个参数需要编码的数据）

        设计此种编码是为了使二进制数据可以通过非纯    8-bit 的传输层传输

        Base64-encoded 数据要比原始数据多占用 33% 左右的空间。

    chunk_split(参数1是要分割的字符，参数2分割的尺寸，参数3行尾序列符号)

        返回值是，分割后的字符串

        将字符串分割成小块

        一般和base64_encode一块用

    realpath(参数1)

        返回规范化的绝对路径名

        参数1要检查的路径

    json_decode(参数1，参数2，参数3，参数4)

        对json格式的字符串进行编码

        参数1带解码的json string格式的字符串

        参数2当为true时将返回array而不是object

        参数3(int $depth=512) 参数4默认将大整数设为浮动

    json_encode(参数1，参数2)

        对变量进行json编码，成功返回一个一json形式便是的string，否侧返回false

        参数1待编码的value，除了resource类型之外的任何类型，只接受utf-8的编码数据

        参数2由一下常量组成二进制掩码：

        JSON_HEX_TAG (integer)

        所有的 &amp;lt; 和 &amp;gt; 转换成 \u003C 和 \u003E。 自 PHP 5.3.0 起生效。

        JSON_HEX_AMP (integer)

        所有的 &amp;amp; 转换成 \u0026。 自 PHP 5.3.0 起生效。

        JSON_HEX_APOS (integer)

        所有的 ' 转换成 \u0027。 自 PHP 5.3.0 起生效。

        JSON_HEX_QUOT (integer)

        所有的 &quot; 转换成 \u0022。 自 PHP 5.3.0 起生效。

        JSON_FORCE_OBJECT (integer)

        使一个非关联数组输出一个类（Object）而非数组。 在数组为空而接受者需要一个类（Object）的时候尤其有用。 自 PHP 5.3.0 起生效。

        JSON_NUMERIC_CHECK (integer)

        将所有数字字符串编码成数字（numbers）。 自 PHP 5.3.3 起生效。

        JSON_BIGINT_AS_STRING (integer)

        将大数字编码成原始字符原来的值。 自 PHP 5.4.0 起生效。

        JSON_PRETTY_PRINT (integer)

        用空白字符格式化返回的数据。 自 PHP 5.4.0 起生效。

        JSON_UNESCAPED_SLASHES (integer)

        不要编码 /。 自 PHP 5.4.0 起生效。

        JSON_UNESCAPED_UNICODE (integer)

        以字面编码多字节 Unicode 字符（默认是编码成 \uXXXX）。 自 PHP 5.4.0 起生效。

    uniqid(参数1，参数2)

        生成一个唯一id，基于当前时间微妙数的唯一id

        参数1返回的字符串长度为13

        参数2如果为more_entropy=true会在返回的字符串结尾增加额外的煽

    http_build_query(参数1，参数2，参数3，参数4)

        生成url-encode之后的请求字符串

        参数1可以是数组或包含属性的对象（只有public的会加入）

        参数2参数3参数4省略

    spl_autoload_register(参数1)

        注册__autoload()函数 成功返回true  否则返回false

        参数1欲注册的自动装载函数，如果没有提供任何函数，则自动注册autoload的默认实现函数spl_autoload()

    get_headers(参数1，参数2)

        取得服务器响应一个http请求所发送的所有标头，成功返回一个索引或关联数组，失败返回false

        参数1  目标url

        参数2 如果设置为1get_headers()会解析相应的信息并设定数组的键名

    ini_set(参数1，参数2)

        为一个配置选项设置值，成功返回旧的值，失败返回false

        参数1为固定的某些值

        参数2选项新的值

    strpos(参数1，参数2，参数3)

        查找字符串首次出现的位置，存在返回当前的位置（默认从0开始），失败返回false

        参数1在该字符串中查找

        参数2如果neddle不是一个字符串，那么他将被转换为整形被视为字符的顺序值

        参数3如果给了，搜索会从字符串该字符的起始位置开始统计，不能为负数

    bool  defined(str参数1)

        检测某个名称的常量是否存在，存在返回true，失败返回false

        参数1，常量的名称

    sha1(参数1，参数2)

        计算字符串的sha1散列值，返回sha1散列值字符串

        参数1，输入的字符串

        参数2，如果为true那么sha1摘要将以20字符长度的原始格式返回，否则返回值是一个40字符串长度的16进制数字

    mcrypt_encrypt（参数1，参数2，参数3，参数4）

        使用给定的参数加密明文，返回加密后的密文，失败返回false

        参数1，字符串值的算法名称或者MCRYPT_ciphername是常量中的一个MCRYPT_RIJNDAEL_128

        参数2，加密密匙，如果长度不是该算法所能够支持的有效长度，则函数将会发出警告并返回false

        参数3，需要加密的串

        参数4，MCRYPT_MODE_modename 常量中的一个，或以下字符串中的一个：&quot;ecb&quot;，&quot;cbc&quot;，&quot;cfb&quot;，&quot;ofb&quot;，&quot;nofb&quot; 和 &quot;stream&quot;。MCRYPT_MODE_CBC

        参数5， $iv = mcrypt_create_iv($iv_size, MCRYPT_RAND);

    list(参数1，参数2，参数3)

        把数组中的值赋给一些变量，返回指定的数组

        参数1一个变量

        ​$info = array('coffee', 'brown', 'caffeine');
        list($a[0], $a[1], $a[2]) = $info;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;</content><summary type="html">一：：session和cookie
	二者的定义：</summary></entry><entry><title type="html">php-two</title><link href="http://localhost:4000/jekyll/update/2016/10/31/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1.html" rel="alternate" type="text/html" title="php-two" /><published>2016-10-31T08:19:35+08:00</published><updated>2016-10-31T08:19:35+08:00</updated><id>http://localhost:4000/jekyll/update/2016/10/31/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1</id><content type="html" xml:base="http://localhost:4000/jekyll/update/2016/10/31/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1.html">&lt;p&gt;对象的主要三个特性
对象的行为：可以对 对象施加那些操作，开灯，关灯就是行为。
对象的形态：当施加那些方法是对象如何响应，颜色，尺寸，外型。
对象的表示：对象的表示就相当于身份证，具体区分在相同的行为与状态下有什么不同。&lt;/p&gt;

&lt;p&gt;面向对象的概念：
oop(面向对象的编程)它能是其代码更加简洁易于维护并且具有更强的可重性&lt;/p&gt;

&lt;p&gt;什么是类：
类是具有相同属性和服务的一组对象的集合比如说人，书，轮船，车都属于类，他为属于该类的对象做了一个统一的抽象描述，在编程的语言中类是一个单独的程序，它应该有一个类名包括属性的说明和服务两个部分。
什么是对象：
对象是系统中描述客观事件的一个实体，他是构成系统的一个基本单位。&lt;em&gt;数据与代码都被捆绑在一个实体当中&lt;/em&gt;，一个对象由一组属性和对这组属性进行操作的一组行为组成。
从抽象的角度来说，对象是问题域或实现域中某些事物的一个抽象。他反映该事物在系统中保存的信息和发挥的作用：它是一组属性和有权对这些属性进行操作的一个封装体。客观世界是由对象和对象之间的联系组成的。
类和对象的关系：
类与对象的关系就如模具和铸件的关系，类的实力化的结果就是对象，而对对象的抽象就是类，类描述了一组有相同特性（属性）和相同行为的对象。&lt;/p&gt;

&lt;p&gt;类与属性和方法&lt;/p&gt;

&lt;p&gt;PHP中定义类语法格式：
复制代码 代码如下:&lt;/p&gt;

&lt;p&gt;class classname [可选属性]{
public $property [=value];… //用public声明一个公共标识 然后给予一个变量 变量也可以赋值
function functionname ( args ){ //类的方法里的成员函数
代码} …
//类的方法（成员函数）
}&lt;/p&gt;

&lt;p&gt;生成对象(类的实例化): $对象名=new classname( );&lt;/p&gt;

&lt;p&gt;使用对象的属性&lt;/p&gt;

&lt;p&gt;在一个类中，可以访问一个特殊指针$this当在该类中通过一个操作设置或访问该变量时,使用$this-&amp;gt;name来引用.
对象的生成
定义好类后用一个new来声明，由于对象资料的封装特性，对象是无法由主程序区块直接访问的须通过对象来调用类中所定义的属性和行为函数，间接地达成存取控制类中资料的目的。
对象和类的关系
对象和类的关系:
对象是实际存在的，占有动态资源。
类是对象的蓝图，可能占有静态资源。
对象属性占有动态资源
类（静态）属性实际上是有类名字空间上的”全局变量”
性能考虑:
每个对象要单独占用数据空间
增加的调用层次可能消耗执行时间
方法的参数形式和传递方式
方法的参数可以是基本数据类型、数组和类对象。
基本数据类型：值参传递
数组：值参传递
类对象：引用传递
构造函数
构造函数是在类中起到初始化的作用
构造函数的生成方法与其他函数一样只是其名称必须是__construct().
语法格式：
function __construct(参数){
。。。。。。。。
}
范例：
复制代码 代码如下:&lt;/p&gt;

&lt;p&gt;class Person{
public $name;
public $sex;
public $age;
function __construct($name,$sex,$age){
echo “我是构造函数&lt;br /&gt;”;
$this-&amp;gt;name=$name;
$this-&amp;gt;sex=$sex;
$this-&amp;gt;age=$age;
}&lt;/p&gt;

&lt;p&gt;输出结果：初始化&lt;/p&gt;

&lt;p&gt;析构函数&lt;/p&gt;

&lt;p&gt;当对象脱离其作用域时（例如对象所在的函数已调用完毕），系统自动执行析构函数。应在退出前在析构函数中用释放内存。
析构函数__destruct 析构函数没有任何参数
范例：
复制代码 代码如下:&lt;/p&gt;

&lt;p&gt;class person{
function _ _destruct( )
{ echo “bye bye !”; }
}
$a=new person();&lt;/p&gt;

&lt;p&gt;访问类型
public 公共的（公共修饰符） 类内部与类外部都可以访问的
private 私有的（私有修饰符） 只能在类内部访问
protected 受保护的（保护成员修饰符） 子类可以访问 类外部不可以访问&lt;/p&gt;

&lt;p&gt;oop的三个重要特性&lt;/p&gt;

&lt;p&gt;封装，继承，多态
封装性：封装性就是把对象的属性和行为结合成一个独立的单位。
封装一个类需要两步 第一步是私有化一个类 第二步是用set和get 做出读取赋值的操作
他的好处是：隐藏类的实现细节，可以方便加入逻辑控制性，限制对属性的不合理操作，便于修改增强代码的可维护性。&lt;/p&gt;

&lt;p&gt;__get与__set
一般说把类私有话更符合现实的逻辑。
预定义两种函数来进行获取与敷值操作。
__get 获取值通常是域的值
__set 设置值通常是域的值
__call 调用一个对象中不存在的方法时，就会产生错误call()这个方法来处理这种情况。&lt;/p&gt;

&lt;p&gt;静态属性和方法&lt;/p&gt;

&lt;p&gt;static关键字 来声明静态方法
static静态变量 在类的内部生成一个静态变量 就是能够被所有类的实力化共想 也就是说静态成员则放到了”初始化静态段”，在类第一次被加载的时候放入的，可以让堆内存里面的每个对象所共享
使用方法：self::$静态属性、self::静态方法
static function p(){
echo self::$country;
echo self::PI;//访问常量
//echo $this-&amp;gt;name;在静态方法中只能操作静态属性
//self::p();
}
外部调用：类::$静态属性、类::静态方法&lt;/p&gt;

&lt;p&gt;const关键字：用来生成常量 常量是唯一的不能改变的 惯例常量为大写
const CONSTANT = ‘constant value’; 生成一个常量
echo self::CONSTANT;//类内部访问
echo ClassName::CONSTANT;//类外部访问&lt;/p&gt;

&lt;p&gt;继承性&lt;/p&gt;

&lt;p&gt;B类的对象拥有A类的全部属性与行为，称作B对A类的继承。
假如一个类从多个类中继承了属性与服务，这称为多继承，通常我们成为继承类为子类被继承类为父类，在PHP中只有单继承，但一个父类可以被多个类继承，但是一个子类只能有一个父类，但是允许关联继承，通过继承可以减化类的定义。
extende声明继承关系
语法格式：class B extends A 此范例指明 B继承了A
类的外部访问对子类是有效的
子类与父类的属性与方法
子类继承父类的所有内容，但父类中的private部分不能直接访问
子类中新增加的属性和方法是对父类的扩展
子类中定义的与父类同名的属性是对父类属性的覆盖，同名的方法也是对父类方法的覆盖&lt;/p&gt;

&lt;p&gt;重写的方法&lt;/p&gt;

&lt;p&gt;在子类中，使用parent访问父类中的被覆盖的属性和方法&lt;/p&gt;

&lt;p&gt;parent::__construce();
parent::$name;
parent::fun();&lt;/p&gt;

&lt;p&gt;覆盖父类原有属性
clone克窿对象 语法格式$c=clone $p; $c克窿的对象$p 输出echo $c-&amp;gt;name;&lt;/p&gt;

&lt;p&gt;对象比较
===两个比较运算符。
==是比较两个对象的内容。
===是比较对象的句柄，即引用地址。&lt;/p&gt;

&lt;p&gt;instanceof操作符用于检测对象实力是否属于某一个类的类型 属于返回true 不属于返回false
__clone()如果想在克隆后改变原对象的内容，需要在__clone()中重写原本的属性和方法
function __clone(){
$this-&amp;gt;name=”我是一个克隆人”;
}&lt;/p&gt;

&lt;p&gt;final表示一个类是最终版本 也就是说它不能在被子类调用&lt;/p&gt;

&lt;p&gt;多态性&lt;/p&gt;

&lt;p&gt;多态性是指在父类中定义的属性或行为被子类继承之后，可以具有不同的数据类型或表现出不同的行为。这使得同一个属性或行为在父类及其各个子类中具有不同的语义。
就是说同一种方法在子类与父类中执行的结果不同。
复制代码 代码如下:&lt;/p&gt;

&lt;p&gt;class A {
function info(){
echo “A INFO”;
}
}
class B extends A {
function info(){
echo “B INFO”;
}
}
class C extends A {
function info(){
echo “C INFO”;
}
}
function printinfo($obj){
function printinfo(A $obj){
if($obj instanceof A)
$obj-&amp;gt;info();
$obj-&amp;gt;info();
}
}
$a=new A(); $b=new B(); $c=new C();
printinfo($a); //输出A INFO
printinfo($b); //输出B INFO
printinfo($c); //输出C INFO&lt;/p&gt;

&lt;p&gt;抽象方法和抽象类&lt;/p&gt;

&lt;p&gt;抽象方法是作为子类摸版使用的。
复制代码 代码如下:&lt;/p&gt;

&lt;p&gt;abstract class Person{
public $name;
abstract function getInfo();
}&lt;/p&gt;

&lt;p&gt;抽象类不能被实力话，一个抽象类中，必须有一个抽象方法。但是抽象类中可以定义动态函数。
接口
当一个类继承了一个接口之后，它要覆盖接口的所有方法，接口只能声明常量，接口的方法必须定义为共有否则无法继承，接口可以与多个接口间继承
语法：
复制代码 代码如下:&lt;/p&gt;

&lt;p&gt;interface PCI{
const TYPE=”PCI”;
//public $name; error
function start();
function stop();
}&lt;/p&gt;

&lt;p&gt;接口中的方法可以声明为static
复制代码 代码如下:&lt;/p&gt;

&lt;p&gt;interface A{ function a();}
interface B{ function b();}
interface C extends A{ function c();}
class D implements B,C{
function a(){}
function b(){}
function c(){}
}&lt;/p&gt;

&lt;p&gt;类
类的声明:
复制代码 代码如下:&lt;/p&gt;

&lt;?php
　　　　权限修饰符 class 类名{ //权限修士符号:public,protected,private 或者省略3者.
　　　　　　//类体;　　　　　　　　//class 是建类关键字
　　　　}　　　　　　　　　　　　　//类名必须跟在class 后面,且跟上{}.{}之间放类的成员.
　　?&gt;
&lt;p&gt;//ps:在class关键字前可以加权限修饰符外,还可以加static,abstract等关键字.一个类,即一对大括号之间的全部内容都要在一段代码段中,不允许将类中的内容分割成对块.
&lt;?php
　　class ConnDB{
　　　　//....
?&gt;
&lt;?
　　　　//...
　　};
?&gt;&lt;/p&gt;

&lt;p&gt;成员属性:
　　在类中直接声明的变量称为成员属性/变量.其类型可以为php中的标量类型和复合类型,使用资源类型和空类型是无效的.
此外,成员属性的声明时,必须要有关键字来修饰:有特定意义的关键字:public,protected,private ;不需要特定意义:var.声明成员属性时,没有必要赋初始值.&lt;/p&gt;

&lt;p&gt;成员常量:&lt;/p&gt;

&lt;p&gt;　　以const常量修饰,例如:const PI = 3.1415926;
　　常量的输出不需要实例化,直接由类名+常量名调用即可,格式为: 类名::常量名
ps. 特殊的访问方法:——–“$this” 和 “::”
1) $”this” 存在于每个成员方法当中,它是一个特殊的对象以用方法.成员方法属于那个对象,$this应用就代表那个对象,其作用就是专门完成对象内部成员之间的访问.
2) “::”成为作用域操作符,使用这个操作符可以在不创建对象的情况下调用类中的常量,变量和方法.　其语法格式如下:&lt;/p&gt;

&lt;p&gt;　　关键字::变量名/常量名/方法名&lt;/p&gt;

&lt;p&gt;　　关键字:parent,可以调用父类成员中的成员变量,成员方法和常量;
　　　　　 self,可以调用当前类中的静态成员和常量;
　　　　　 类名,可以调用类中的常量,变量和方法;　　　
　　
成员方法:&lt;/p&gt;

&lt;p&gt;　　在类中声明的函数成为成员方法,在一个类中可以声明多个函数,即对象可以拥有多个成员方法.成员方法的声明和函数的声明相同,唯一特殊之处就是成员方法可以有关键字对它进行修饰,从而控制其访问权限.
类的实例化&lt;/p&gt;

&lt;p&gt;　　创建对象:&lt;/p&gt;

&lt;p&gt;　　　　$变量名 = new 类名称([参数]); //类的实例化.
　　访问类成员:
　　　　$变量名 -&amp;gt; 成员属性 = 值;
构造方法和析构方法
构造方法是对象创建完成后第一个呗对象自动调用的方法.它存在每个类的声明当中,是一个特殊的成员方法,一般用来完成一些初始化操作.如果类中没有构造方法,系统会默认自动生成一个没有参数的构造方法.
　　格式:
复制代码 代码如下:&lt;/p&gt;

&lt;p&gt;function _construct(形参列表){
　　　　　　//方法体
　　　　};&lt;/p&gt;

&lt;p&gt;析构方法则如构造方法相反,它是在对象被销毁前最后一个调用的方法.它将完成一个特定的操作,如关闭文件和释放内存.
　　格式:
复制代码 代码如下:&lt;/p&gt;

&lt;p&gt;function _destruct(){
　　　　　　//方法体　
　　　　};&lt;/p&gt;

&lt;p&gt;面向对象特点:封装性,抽象性,多态性.
封装:
　　将类中的成员属性和方法结合成一个独立的相同单位,并且尽可能的隐藏对象的内容细节.其目的是确保类以外的部分不能随意存取类的内部数据(成员属性和成员方法),从而避免外部错误对内部数据的影响.
　　类的封装是通过关键字public,private,protected,static和final实现的.各关键字的作用请查看php相关文档.
继承性:
　　使一个类继承并拥有另一个已存在的类的成员属性和成员方法,其中被继承的类成为父类,继承的类成为子类.通过继承能够提高代码的重用性和可维护性.类的继承用 extends 关键字.
　　格式:
复制代码 代码如下:&lt;/p&gt;

&lt;p&gt;class 子类名称 extends 父类名称{
　　　　　　//子类方法体.
　　　　}&lt;/p&gt;

&lt;p&gt;通过parent::关键字也可以在子类方法中调用父类的成员方法,格式如下:
　　parent::父类的成员方法(参数);&lt;/p&gt;

&lt;p&gt;覆盖父类的方法:&lt;/p&gt;

&lt;p&gt;　　所谓的覆盖父类的方法,也就是使用子类中的方法替换从父类中继承的方法,也叫方法的重写.重写的关键就在与子类中创建与父类中相同的方法,g包括方法名称,参数和返回类型.&lt;/p&gt;

&lt;p&gt;多态性:
　　多态性是指一段程序能够处理多种类型对象的能力.php多态有两种实现方法,即通过继承实现多态和通过接口实现多态.
通过继承实现多态,即通过重写继承的成员方法来达到多态的效果.
复制代码 代码如下:&lt;/p&gt;

&lt;?php
abstract class ParentClass{
abstract function printMessage();
}
class SubClassA extends ParentClass{
function printMessage(){
echo &quot;i am message from class A&quot;;
}
}
class SubClassB extends ParentClass{
function printMessage(){
echo &quot;i am message from class B&quot;;
}
}
function printMSG($object){
if( $object instanceof ParentClass){
$object-&gt;printMessage();
}else{
echo &quot;error!&quot;;
}
}
$objectA=new SubClassA();
printMSG($objectA);
$objectB=new SubClassB();
printMSG($objectB);
?&gt;

&lt;p&gt;通过接口实现多态,通过定义接口,与空方法.然后类继承接口.
复制代码 代码如下:&lt;/p&gt;

&lt;?php
interface interfaceInfo{
function printMessage();
}
class ClassA implements interfaceInfo{
function printMessage(){
echo &quot;message form class A&quot;;
}
}
class ClassB implements interfaceInfo{
function printMessage(){
echo &quot;message form class B&quot;;
}
}
function printMSG($object){
if($object instanceof interfaceInfo){
$object -&gt; printMessage();
}else{
echo &quot;error !&quot;;
}
}
$objectA =new ClassA();
printMSG($objectA);
$objectB =new ClassB();
printMSG($objectB);
?&gt;

&lt;p&gt;ps. 抽象类和接口.
抽象类和接口都是不能被实例化的特殊类.他们都是能够配合面向对象多态性一起使用.
抽象类:
　　抽象类是一种不能实例化的类,只能作为其他类的父类来使用.抽象类使用abstract 关键字来声明,其格式如下:
复制代码 代码如下:&lt;/p&gt;

&lt;p&gt;abstract class 抽象类名{
　　　　　　abstract function 成员方法(参数);//
　　　　}&lt;/p&gt;

&lt;p&gt;抽象类和普通类相似,包含成员变量,成员方法.两者区别在于抽象类至少要包含一个抽象方法.抽象方法没有方法体,其功能的实现只能在子类中完成.抽象方法也使用关键字 abstract 来修饰.&lt;/p&gt;

&lt;p&gt;接口:
　　继承特性简化了对象和类的创建,增强了代码的可重用性.但php只支持单继承,如果想实现多重继承,就要使用接口.
接口的声明:通过interface 关键字来实现,接口中声明的方法必须是抽象方法,接口中不能声明变量,只能使用const 关键字声明为常量的成员属性,并且接口中所有成员都必须具备puclic 的访问权限.ainterface 声明接口格式如下:
复制代码 代码如下:&lt;/p&gt;

&lt;p&gt;inerface 接口名称{
　　 //常量成员;//成员只能是常量.
　　 //抽象方法;
　　}&lt;/p&gt;

&lt;p&gt;由于接口不能实现实例化操作,因此只能借助子类继承接口的形式来实现.实现的格式是:
复制代码 代码如下:&lt;/p&gt;

&lt;p&gt;Class 子类名 implements 接口名1[,接口名2,接口名3,…..]{
　　//子类方法体.
}&lt;/p&gt;

&lt;p&gt;常用关键字:
　　1) final:final之意为最终的,最后的.这就以为着通过final 关键字修饰的类和方法都为最终版本.不能被继承,也不能有子类.不能重写,也不能被覆盖.
　　2) static: 通过static 关键字修饰的成员属性和成员方法称为静态属性和静态方法.静态成员属性和方法不需要被实例化就能直接使用.
　　　静态属性:它属于类本身,而不属于类的任何实例.它相当于存储在类中的全局变量,可以在任何位置通过类来访问.访问格式为:
　　　　　　类名称::$静态属性名称;
　　　　　　如果你要在类内部的成员方法中访问静态属性,那么在静态属性的名称前加上操作符: “self::” 即可.
　　　静态方法:由于其不受任何对象限制,因此可以不通过类的实例化而直接引用类中的静态方法.引用格式如下:
　　　　　　类名称::静态方法名(参数);
　　　　　　如果你要在类内部的成员方法中调用静态方法,那么在静态方法的名称前加上操作符: “self::” 即可.在静态方法中只能调用静态变量,而不能调用普通变量;而普通方法中则可以调用静态变量.
使用静态成员除了不需要实例化外,另一个作用是在对象被销毁后,仍然保留呗修改的静态数据,以便下次调用.
　　3) clone.对象的克隆可以通过关键字来实现.使用clone对象与原对象没有任何关系,即克隆对象会重新申请一份存储空间来存放原对象内容.格式如下:
　　　　　　$克隆对象 = clone $原克隆对象名称;
　　　　克隆成功后,他们的n成员方法,属性以及值完全相等.如果要对副本重新初始化,就要用到 _clone().
　　　　　魔术方法_clone()可以对克隆后的副本对象重新初始化.它不需要任何参数,其中自动包含$this (副本对象)和 $that (原对象) 对象的引用.
对象的比较:
　　”==” 表示比较两个对象的内容,”===”表示比较两个对象的引用地址相等.
对象类型的检测: instanceof 操作符可以检测当前对象属于那个对象.&lt;/p&gt;

&lt;p&gt;面向对象—常用魔术方法:
以上我们已经了解的常用魔术方法有:_construct(),_destruct(),_clone.下面我们再接着介绍几个常用魔术方法.
_get(),_set();
　　以上两个方法用于对私有成员精细复制或者获取值的操作.
　　_set()在程序运行中为私有的成员属性设置值,它不需要任何返回值._set()方法包括两个不可省略的参数:变量名和变量值.这个方法不需要主动调用,可在方法钱加上prive关键字.
　　_get():在程序运行中,在对象的外部获取私有成员的属性的值.他有一个参数:私有成员属性名称.他返回一个允许对象在外部使用的值.此方法同样不许主动调用.&lt;/p&gt;

&lt;p&gt;_isset(),_unset():
　　isset()函数用于检测变量是否存在.而在面向对象中可以通过isset()函数对公有的成员属性进行检测,但对私有成员属性,此函数则不起作用.因此,_isset()函数正是为了起到此作用而创建.格式如下:
　　bool _isset(string name);
　　_unset()则同样为了删除制定的变量和对象的私有成员属性.格式如下:
　　void _unset(string name);//
_call():
　　_call()方法的作用是当程序试图调用不存在或不可见的成员方法时,php会先调用_call()方法来存储方法名及其参数(方法名和方法参数).其中方法参数是以数组的形式存在.
_toString()方法:
　　其作用是当使用echo 或者print输出对象时,将对象转化为字符串.
　　如果没有_toString()方法,直接输出对象时将会发生致命错误.
　　输出对象时应注意的是,echo 或print 语句后面直接跟要输出的对象,中间不要加多余的字符,否则_toSting()将不会被执行.
_autoload()方法:
　　将一个独立的,完整的类保存到一个php页中,并且文件名和类名保持一致,这是每个开发人员都需要养成的良好习惯.这样下次在使用的时候就能够轻松的找到它.但有一种情况:如果要在一个页面中引进很多的类,就需要使用include_once()函数或者require_once()函数一个个地引入.php5中引入_autoload()方法可以自动实例化需要使用的类.当一个类还没实例化时,_autoload()会自动到指定的路径下面自动查找和类名相同的文件.找到则继续执行,否则报错.
复制代码 代码如下:&lt;/p&gt;

&lt;?php
　　function _autoload($class_name){
　　　　$class_path = $class_name.'.class.php';
　　　　if(file_exists($class_path)){
　　　　　　include_once($class_path);
　　　　}else{
　　　　　　echo '类不存在或者类路径错误';
　　　　}
}
　　$class = new Class(); //将会自动加载.
　　echo $class; //输出类内容.如自定义了_toString()方法;则会输出_toString()中定义的内容.
?&gt;

&lt;p&gt;面向对象和面向过程的区别
面向过程就是分析出解决问题所需要的步骤，然后用函数把这些步骤一步一步实现，使用的时候一个一个依次调用就可以了。&lt;/p&gt;

&lt;p&gt;面向对象是把构成问题事务分解成各个对象，建立对象的目的不是为了完成一个步骤，而是为了描叙某个事物在整个解决问题的步骤中的行为。&lt;/p&gt;

&lt;p&gt;例如五子棋，面向过程的设计思路就是首先分析问题的步骤：1、开始游戏，2、黑子先走，3、绘制画面，4、判断输赢，5、轮到白子，6、绘制画面，7、判断输赢，8、返回步骤2，9、输出最后结果。把上面每个步骤用分别的函数来实现，问题就解决了。&lt;/p&gt;

&lt;p&gt;而面向对象的设计则是从另外的思路来解决问题。整个五子棋可以分为 1、黑白双方，这两方的行为是一模一样的，2、棋盘系统，负责绘制画面，3、规则系统，负责判定诸如犯规、输赢等。第一类对象（玩家对象）负责接受用户输入，并告知第二类对象（棋盘对象）棋子布局的变化，棋盘对象接收到了棋子的i变化就要负责在屏幕上面显示出这种变化，同时利用第三类对象（规则系统）来对棋局进行判定。&lt;/p&gt;

&lt;p&gt;可以明显地看出，面向对象是以功能来划分问题，而不是步骤。同样是绘制棋局，这样的行为在面向过程的设计中分散在了总多步骤中，很可能出现不同的绘制版本，因为通常设计人员会考虑到实际情况进行各种各样的简化。而面向对象的设计中，绘图只可能在棋盘对象中出现，从而保证了绘图的统一。&lt;/p&gt;

&lt;p&gt;功能上的统一保证了面向对象设计的可扩展性。比如我要加入悔棋的功能，如果要改动面向过程的设计，那么从输入到判断到显示这一连串的步骤都要改动，甚至步骤之间的循序都要进行大规模调整。如果是面向对象的话，只用改动棋盘对象就行了，棋盘系统保存了黑白双方的棋谱，简单回溯就可以了，而显示和规则判断则不用顾及，同时整个对对象功能的调用顺序都没有变化，改动只是局部的。&lt;/p&gt;

&lt;p&gt;再比如我要把这个五子棋游戏改为围棋游戏，如果你是面向过程设计，那么五子棋的规则就分布在了你的程序的每一个角落，要改动还不如重写。但是如果你当初就是面向对象的设计，那么你只用改动规则对象就可以了，五子棋和围棋的区别不就是规则吗？（当然棋盘大小好像也不一样，但是你会觉得这是一个难题吗？直接在棋盘对象中进行一番小改动就可以了。）而下棋的大致步骤从面向对象的角度来看没有任何变化。&lt;/p&gt;

&lt;p&gt;当然，要达到改动只是局部的需要设计的人有足够的经验，使用对象不能保证你的程序就是面向对象，初学者或者很蹩脚的程序员很可能以面向对象之虚而行面向过程之实，这样设计出来的所谓面向对象的程序很难有良好的可移植性和可扩展性。&lt;/p&gt;

&lt;p&gt;这是我曾经看过的一个有关于面向对象的资料：http://www.cnblogs.com/xiaochaohuashengmi/archive/2010/09/10/1823042.html&lt;/p&gt;</content><summary type="html">对象的主要三个特性
对象的行为：可以对 对象施加那些操作，开灯，关灯就是行为。
对象的形态：当施加那些方法是对象如何响应，颜色，尺寸，外型。
对象的表示：对象的表示就相当于身份证，具体区分在相同的行为与状态下有什么不同。</summary></entry><entry><title type="html">CodeIgniter配置之SESSION</title><link href="http://localhost:4000/jekyll/update/2015/12/05/CodeIgniter%E9%85%8D%E7%BD%AE%E4%B9%8BSESSION.html" rel="alternate" type="text/html" title="CodeIgniter配置之SESSION" /><published>2015-12-05T14:02:13+08:00</published><updated>2015-12-05T14:02:13+08:00</updated><id>http://localhost:4000/jekyll/update/2015/12/05/CodeIgniter%E9%85%8D%E7%BD%AE%E4%B9%8BSESSION</id><content type="html" xml:base="http://localhost:4000/jekyll/update/2015/12/05/CodeIgniter%E9%85%8D%E7%BD%AE%E4%B9%8BSESSION.html">&lt;p&gt;CodeIgniter配置之SESSION&lt;/p&gt;

&lt;p&gt;刚使用Codeigniter时也被其中的SESSION迷惑过，后来就再也没用过CI自带的SESSION，想必还是有必要整理一下 SESSION。为弄清CI中的SESSION，先来说一下PHP中SESSION是如何工作的。由于HTTP协议本身是无状态的，所以当保留某个用户的 访问状态信息时，需要客户端有一个唯一标识传给服务端，这个唯一标识就是SESSION ID，存放在客户端的COOKIE中，然后服务端根据该标识读取存放的用户状态信息，达到保存会话状态的目的。PHP中启动一个会话需要执行下面语句：
1	session_start();
1、客户端每次请求时会有一些信息存放中HTTP头中发送给服务端，以用户第一次访问为例：
Request Headers
Accept:text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,&lt;em&gt;/&lt;/em&gt;;q=0.8
Accept-Encoding:gzip,deflate,sdch
Accept-Language:zh-CN,zh;q=0.8
Cache-Control:max-age=0
Connection:keep-alive
Host:s.local
User-Agent:Mozilla/5.0 (Windows NT 6.1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/31.0.1650.63 Safari/537.36
2、服务端接到请求处理后并返回给客户端，并在HTTP Response中加上添加COOKIE的请求，告诉浏览器需要设置一个COOKIE，COOKIE名为PHPSESSID，值为r887k5n4scg32d4ba34huuhmq7，如：
Response Headers
Cache-Control:no-store, no-cache, must-revalidate, post-check=0, pre-check=0
Connection:Keep-Alive
Content-Length:0
Content-Type:text/html
Date:Sun, 08 Dec 2013 12:56:56 GMT
Expires:Thu, 19 Nov 1981 08:52:00 GMT
Keep-Alive:timeout=5, max=100
Pragma:no-cache
Server:Apache/2.2.11 (Win32) PHP/5.4.7
Set-Cookie:PHPSESSID=r887k5n4scg32d4ba34huuhmq7; path=/
X-Powered-By:PHP/5.4.7
3、当客户端再次访问该网站的页面时，浏览器会将该COOKIE发送给服务端，服务端根据COOKIE的值去读取服务器上存放SESSION的文件，拿到到会话信息，如：
Request Headers
Accept:text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,&lt;em&gt;/&lt;/em&gt;;q=0.8
Accept-Encoding:gzip,deflate,sdch
Accept-Language:zh-CN,zh;q=0.8
Cache-Control:max-age=0
Connection:keep-alive
Cookie:PHPSESSID=r887k5n4scg32d4ba34huuhmq7
Host:s.local
User-Agent:Mozilla/5.0 (Windows NT 6.1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/31.0.1650.63
从而达到保存会话状态的目的。但也需要注意，如果获取到用户A登录的SESSION ID会怎么样？根据上面的逻辑，如果在请求过程中把获取到的SESSION ID一并发送给服务端，服务端根据SESSION ID读取文件，发现文件内容存在，从而判定用户为A用户，也就是获取到了A用户的用户状态，从而可能可以进行一些敏感操作。所以在会话有效期内，获取到了 SESSION ID即获取到了用户的授权，这是比较危险的，以本地的一个管理系统为例，通过chrome登录后查看到客户端COOKIE：&lt;/p&gt;

&lt;p&gt;假如如果通过某种手段获取到了SESSION ID， 可以模拟发送一个相同的COOKIE过去即可实现登录。FireFox中可添加COOKIE，打开Firebug后Cookies中新建cookie，确定之后刷新页面即可登录到管理系统：&lt;/p&gt;

&lt;p&gt;通常情况下可通过js获取到cookie，所以需要注意转义，防止数据展示时被执行了。接下来看看CI中的SESSION。在配置文件中有几个跟Session配置相关的参数，影响到Session的使用，它们是：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;1://session保存在cookie中的名称
2:$config['sess_cookie_name'] = 'ci_session';
3://session的有效时间
4:$config['sess_expiration']  = 7200;
5://是否关闭浏览器session失效
6:$config['sess_expire_on_close'] = FALSE;
7://SESSION是否加密存放在COOKIE中
8:$config['sess_encrypt_cookie']  = FALSE;
9://是否保存在数据库中
10:$config['sess_use_database']    = FALSE;
11://存在数据库中，则数据库表名
12:$config['sess_table_name']  = 'ci_sessions';
13://是否匹配IP
14:$config['sess_match_ip']    = FALSE;
15://是否匹配UserAgent
16:$config['sess_match_useragent'] = TRUE;
17://更新时间时间
18:$config['sess_time_to_update']  = 300;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;CI自带的SESSION没有服务端文件存储，所有的信息都存放在客户端COOKIE中，当调用$this-&amp;gt;load-&amp;gt;library(‘session’);时会启动一个会话，即设置一个COOKIE，COOKIE的内容如下：
Array
(
[session_id] =&amp;gt; f05138a9513e4928cb0a57672cfe3b53
[ip_address] =&amp;gt; 127.0.0.1
[user_agent] =&amp;gt; Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/31.0.1650.63 Safari/537.36
[last_activity] =&amp;gt; 1386569398
[user_data] =&amp;gt;
) 
当客户端请求时会将这些信息在HTTP头中传输给服务端，服务端从HTTP头中读取到SESSION信息。同样的可以实现会话，但该方式有很多的不确定因素，根据源码说几点吧：
1、 如果日志文件中出现：The session cookie data did not match what was expected. This could be a possible hacking attempt.说明两个问题：a.sess_encrypt_cookie为false，SESSION在COOKIE中未加密存放 b.读取到COOKIE后，校验失败。涉及到加解密、参数处理的情况，容易出现匹配不通过的情况，若不通过则清空SESSION。
2、如果sess_match_ip为true，当客户端IP变化时，SESSION将校验不通过，从而清空SESSION。
3、sess_match_useragent默认为true，当客户端UserAgent变化时，校验不通过，清空SESION。简单的例子，通过IE浏览器访问，若切换到不同的IE模式，Agent不同，所以校验不通过，清空SESSION。
可以看到，当出现上面任何一种情况时，SESSION都会清空，出现登录不成功或者跳转到登录页面的情况。如果说不加密、不校验IP、 UserAgent呢？因为COOKIE是存放在客户端，需要伴随HTTP请求发给服务端，一来过多的COOKIE会影响速度，对一些图片等资源来说完全 时浪费带宽；二来COOKIE只能存储4K的数据，加密处理后能存放的更小。
种种的不确定因素将产生各种奇怪的问题，避免过多的纠结，果断改用其他方式吧。&lt;/p&gt;</content><summary type="html">CodeIgniter配置之SESSION</summary></entry><entry><title type="html">商品加入购物车</title><link href="http://localhost:4000/2015/11/27/%E5%95%86%E5%93%81%E5%8A%A0%E5%85%A5%E8%B4%AD%E7%89%A9%E8%BD%A6.html" rel="alternate" type="text/html" title="商品加入购物车" /><published>2015-11-27T00:00:00+08:00</published><updated>2015-11-27T00:00:00+08:00</updated><id>http://localhost:4000/2015/11/27/%E5%95%86%E5%93%81%E5%8A%A0%E5%85%A5%E8%B4%AD%E7%89%A9%E8%BD%A6</id><content type="html" xml:base="http://localhost:4000/2015/11/27/%E5%95%86%E5%93%81%E5%8A%A0%E5%85%A5%E8%B4%AD%E7%89%A9%E8%BD%A6.html">&lt;p&gt;购物车实现：
1、分析购物需要保存哪些信息？
页面展示信息：
商品名称 + 商品Sku描述
单品价格 （商品价格 + sku价格）&lt;/p&gt;

&lt;p&gt;商品图片（暂时忽略）&lt;/p&gt;

&lt;p&gt;//入库需要，隐藏域传递数据
商品id
sku_no&lt;/p&gt;

&lt;p&gt;2、页面中获取第1步中的相应信息&lt;/p&gt;

&lt;p&gt;3、第2步中的数据作为参数，ajax请求到处理页&lt;/p&gt;

&lt;p&gt;4、定义上一步ajax请求的方法
关键代码
4.1  未登录 通过 json_decode() 转成字符串存入cookie&lt;/p&gt;

&lt;p&gt;4.2 登录状态 数据库操作购物车&lt;/p&gt;

&lt;p&gt;5、展示购物车中的商品&lt;/p&gt;

&lt;p&gt;控制器代码
$data[‘cards’] = json_decode(get_cookie(‘cards’),true);&lt;/p&gt;

&lt;p&gt;模版代码&lt;/p&gt;</content><summary type="html">购物车实现：
1、分析购物需要保存哪些信息？
页面展示信息：
商品名称 + 商品Sku描述
单品价格 （商品价格 + sku价格）</summary></entry><entry><title type="html">利用phpExcel实现Excel数据的导入导出</title><link href="http://localhost:4000/jekyll/update/2015/11/21/%E5%88%A9%E7%94%A8phpExcel%E5%AE%9E%E7%8E%B0Excel%E6%95%B0%E6%8D%AE%E7%9A%84%E5%AF%BC%E5%85%A5%E5%AF%BC%E5%87%BA.html" rel="alternate" type="text/html" title="利用phpExcel实现Excel数据的导入导出" /><published>2015-11-21T14:52:13+08:00</published><updated>2015-11-21T14:52:13+08:00</updated><id>http://localhost:4000/jekyll/update/2015/11/21/%E5%88%A9%E7%94%A8phpExcel%E5%AE%9E%E7%8E%B0Excel%E6%95%B0%E6%8D%AE%E7%9A%84%E5%AF%BC%E5%85%A5%E5%AF%BC%E5%87%BA</id><content type="html" xml:base="http://localhost:4000/jekyll/update/2015/11/21/%E5%88%A9%E7%94%A8phpExcel%E5%AE%9E%E7%8E%B0Excel%E6%95%B0%E6%8D%AE%E7%9A%84%E5%AF%BC%E5%85%A5%E5%AF%BC%E5%87%BA.html">&lt;p&gt;利用phpExcel实现Excel数据的导入导出(全步骤详细解析)
很多文章都有提到关于使用phpExcel实现Excel数据的导入导出，大部分文章都差不多，或者就是转载的，都会出现一些问题，下面是本人研究phpExcel的使用例程总结出来的使用方法，接下来直接进入正题。 
首先先说一下，本人的这段例程是使用在Thinkphp的开发框架上，要是使用在其他框架也是同样的方法，很多人可能不能正确的实现Excel的导入导出，问题基本上都是phpExcel的核心类引用路径出错，如果有问题大家务必要对路劲是否引用正确进行测试。
（一）导入Excel
第一，在前台html页面进行上传文件：如：
复制代码 代码如下:&lt;/p&gt;

&lt;form method=&quot;post&quot; action=&quot;php文件&quot; enctype=&quot;multipart/form-data&quot;&gt;
         &lt;h3&gt;导入Excel表：&lt;/h3&gt;&lt;input type=&quot;file&quot; name=&quot;file_stu&quot; /&gt;
           &lt;input type=&quot;submit&quot; value=&quot;导入&quot; /&gt;
&lt;/form&gt;

&lt;p&gt;第二，在对应的php文件进行文件的处理
复制代码 代码如下:&lt;/p&gt;

&lt;p&gt;if (! empty ( $_FILES [‘file_stu’] [‘name’] )) 
 {
    $tmp_file = $_FILES [‘file_stu’] [‘tmp_name’];
    $file_types = explode ( “.”, $_FILES [‘file_stu’] [‘name’] );
    $file_type = $file_types [count ( $file_types ) - 1];
     /&lt;em&gt;判别是不是.xls文件，判别是不是excel文件&lt;/em&gt;/
     if (strtolower ( $file_type ) != “xls”)            &lt;br /&gt;
    {
          $this-&amp;gt;error ( ‘不是Excel文件，重新上传’ );
     }
    /&lt;em&gt;设置上传路径&lt;/em&gt;/
     $savePath = SITE_PATH . ‘/public/upfile/Excel/’;
    /&lt;em&gt;以时间来命名上传的文件&lt;/em&gt;/
     $str = date ( ‘Ymdhis’ ); 
     $file_name = $str . “.” . $file_type;
     /&lt;em&gt;是否上传成功&lt;/em&gt;/
     if (! copy ( $tmp_file, $savePath . $file_name )) 
      {
          $this-&amp;gt;error ( ‘上传失败’ );
      }
    /*
       &lt;em&gt;对上传的Excel数据进行处理生成编程数据,这个函数会在下面第三步的ExcelToArray类中
      注意：这里调用执行了第三步类里面的read函数，把Excel转化为数组并返回给$res,再进行数据库写入
    */
  $res = Service ( ‘ExcelToArray’ )-&amp;gt;read ( $savePath . $file_name );
   /&lt;/em&gt;
        重要代码 解决Thinkphp M、D方法不能调用的问题 &lt;br /&gt;
        如果在thinkphp中遇到M 、D方法失效时就加入下面一句代码
    &lt;em&gt;/
   //spl_autoload_register ( array (‘Think’, ‘autoload’ ) );
   /&lt;/em&gt;对生成的数组进行数据库的写入*/
   foreach ( $res as $k =&amp;gt; $v ) 
   {
       if ($k != 0) 
      {
           $data [‘uid’] = $v [0];
           $data [‘password’] = sha1 ( ‘111111’ );
           $data [‘email’] = $v [1];
           $data [‘uname’] = $v [3];
          $data [‘institute’] = $v [4];
         $result = M ( ‘user’ )-&amp;gt;add ( $data );
         if (! $result) 
         {
              $this-&amp;gt;error ( ‘导入数据库失败’ );
          }
      }
   }
}&lt;/p&gt;

&lt;p&gt;第三：ExcelToArrary类,用来引用phpExcel并处理Excel数据的
复制代码 代码如下:&lt;/p&gt;

&lt;p&gt;class ExcelToArrary extends Service{
 public function __construct() {
     /&lt;em&gt;导入phpExcel核心类    注意 ：你的路径跟我不一样就不能直接复制&lt;/em&gt;/
     include_once(‘./Excel/PHPExcel.php’);
 }
/**&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;读取excel $filename 路径文件名 $encode 返回数据的编码 默认为utf8
*以下基本都不要修改
*/ 
public function read($filename,$encode=’utf-8’){
        $objReader = PHPExcel_IOFactory::createReader(‘Excel5’); 
        $objReader-&amp;gt;setReadDataOnly(true); 
        $objPHPExcel = $objReader-&amp;gt;load($filename); 
        $objWorksheet = $objPHPExcel-&amp;gt;getActiveSheet(); 
　　　 $highestRow = $objWorksheet-&amp;gt;getHighestRow(); 
　　　 $highestColumn = $objWorksheet-&amp;gt;getHighestColumn(); 
　　    $highestColumnIndex = PHPExcel_Cell::columnIndexFromString($highestColumn); 
 　　   $excelData = array(); 
 　　　for ($row = 1; $row &amp;lt;= $highestRow; $row++) { 
  　　  for ($col = 0; $col &amp;lt; $highestColumnIndex; $col++) { 
               $excelData[$row][] =(string)$objWorksheet-&amp;gt;getCellByColumnAndRow($col, $row)-&amp;gt;getValue();
         } 
       } 
      return $excelData; 
  }   &lt;br /&gt;
 }&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;第四，以上就是导入的全部内容，phpExcel包附在最后。
（二）Excel的导出（相对于导入简单多了）
第一，先查出数据库里面要生成Excel的数据，如：
$data= M(‘User’)-&amp;gt;findAll();   //查出数据
$name=’Excelfile’;    //生成的Excel文件文件名
$res=service(‘ExcelToArrary’)-&amp;gt;push($data,$name);
第二，ExcelToArrary类,用来引用phpExcel并处理数据的  &lt;br /&gt;
复制代码 代码如下:&lt;/p&gt;

&lt;p&gt;class ExcelToArrary extends Service{
       public function __construct() {
              /&lt;em&gt;导入phpExcel核心类    注意 ：你的路径跟我不一样就不能直接复制&lt;/em&gt;/
               include_once(‘./Excel/PHPExcel.php’);
       }
     /* 导出excel函数&lt;em&gt;/
    public function push($data,$name=’Excel’){
          error_reporting(E_ALL);
          date_default_timezone_set(‘Europe/London’);
         $objPHPExcel = new PHPExcel();
        /&lt;/em&gt;以下是一些设置 ，什么作者  标题啊之类的&lt;em&gt;/
         $objPHPExcel-&amp;gt;getProperties()-&amp;gt;setCreator(“转弯的阳光”)
                               -&amp;gt;setLastModifiedBy(“转弯的阳光”)
                               -&amp;gt;setTitle(“数据EXCEL导出”)
                               -&amp;gt;setSubject(“数据EXCEL导出”)
                               -&amp;gt;setDescription(“备份数据”)
                               -&amp;gt;setKeywords(“excel”)
                              -&amp;gt;setCategory(“result file”);
         /&lt;/em&gt;以下就是对处理Excel里的数据， 横着取数据，主要是这一步，其他基本都不要改*/
        foreach($data as $k =&amp;gt; $v){
             $num=$k+1;
             $objPHPExcel-&amp;gt;setActiveSheetIndex(0)
                         //Excel的第A列，uid是你查出数组的键值，下面以此类推
                          -&amp;gt;setCellValue(‘A’.$num, $v[‘uid’])  &lt;br /&gt;
                          -&amp;gt;setCellValue(‘B’.$num, $v[‘email’])
                          -&amp;gt;setCellValue(‘C’.$num, $v[‘password’])
            }
            $objPHPExcel-&amp;gt;getActiveSheet()-&amp;gt;setTitle(‘User’);
            $objPHPExcel-&amp;gt;setActiveSheetIndex(0);
             header(‘Content-Type: application/vnd.ms-excel’);
             header(‘Content-Disposition: attachment;filename=”’.$name.’.xls”’);
             header(‘Cache-Control: max-age=0’);
             $objWriter = PHPExcel_IOFactory::createWriter($objPHPExcel, ‘Excel5’);
             $objWriter-&amp;gt;save(‘php://output’);
             exit;
      }&lt;/p&gt;

&lt;p&gt;以上就是导出的全部内容。&lt;/p&gt;</content><summary type="html">利用phpExcel实现Excel数据的导入导出(全步骤详细解析)
很多文章都有提到关于使用phpExcel实现Excel数据的导入导出，大部分文章都差不多，或者就是转载的，都会出现一些问题，下面是本人研究phpExcel的使用例程总结出来的使用方法，接下来直接进入正题。 
首先先说一下，本人的这段例程是使用在Thinkphp的开发框架上，要是使用在其他框架也是同样的方法，很多人可能不能正确的实现Excel的导入导出，问题基本上都是phpExcel的核心类引用路径出错，如果有问题大家务必要对路劲是否引用正确进行测试。
（一）导入Excel
第一，在前台html页面进行上传文件：如：
复制代码 代码如下:</summary></entry><entry><title type="html">php发送邮件</title><link href="http://localhost:4000/jekyll/update/2015/11/09/php%E5%8F%91%E9%80%81%E9%82%AE%E4%BB%B6.html" rel="alternate" type="text/html" title="php发送邮件" /><published>2015-11-09T10:46:13+08:00</published><updated>2015-11-09T10:46:13+08:00</updated><id>http://localhost:4000/jekyll/update/2015/11/09/php%E5%8F%91%E9%80%81%E9%82%AE%E4%BB%B6</id><content type="html" xml:base="http://localhost:4000/jekyll/update/2015/11/09/php%E5%8F%91%E9%80%81%E9%82%AE%E4%BB%B6.html">&lt;p&gt;知识点：邮件相关的协议：
smtp：发邮件，端口：25
pop3：收邮件，端口：110&lt;/p&gt;

&lt;p&gt;1、要有邮件服务器
a)	自己搭建一个邮箱服务器
b)	使用现有的：126、163等等。
163发邮件的接口：smtp.163.com    ssl://smtp.qq.com
2、在163注册一个邮箱账号
在php中发送邮件使用一个 phpmailer的类。
phpmailer发送邮件示例
注意事项：
启用fsockopen函数
首先，在php.ini中去掉下面的两个分号
复制代码 代码示例:
extension=php_sockets.dll 
extension=php_openssl.dll&lt;/p&gt;

&lt;p&gt;代码案例：
&amp;lt;?php
 require ‘PHPMailer/class.phpmailer.php’;
 $mail             = new PHPMailer();
/&lt;em&gt;服务器相关信息&lt;/em&gt;/
		$mail-&amp;gt;IsSMTP();                        //设置使用SMTP服务器发送
		$mail-&amp;gt;SMTPAuth   = true;               //开启SMTP认证
		$mail-&amp;gt;Host       = ‘smtp.163.com’;   	    //设置 SMTP 服务器,自己注册邮箱服务器地址
		$mail-&amp;gt;Username   = ‘lau0400810121’;  		//发信人的邮箱名称
		$mail-&amp;gt;Password   = ‘lau13142yun’;          //发信人的邮箱密码
		/&lt;em&gt;内容信息&lt;/em&gt;/
		$mail-&amp;gt;IsHTML(true); 			         //指定邮件格式为：html
		$mail-&amp;gt;CharSet    =”UTF-8”;			     //编码
		$mail-&amp;gt;From       = ‘lau0400810121@163.com’;			 //发件人完整的邮箱名称
		$mail-&amp;gt;FromName   = ‘地球球长委员会’;			 //发信人署名
		$mail-&amp;gt;Subject    = “地球的球长选举”;  			 //信的标题
		$mail-&amp;gt;MsgHTML(“尊敬的用户：明天开会，会后，我请客”);  				 //发信主体内容
        /&lt;em&gt;发送邮件&lt;/em&gt;/
		$mail-&amp;gt;AddAddress(“18665455185@163.com”);  			 //收件人地址
        //使用send函数进行发送
		if($mail-&amp;gt;Send()) {
			echo ‘ok ok’;
		} else {
            echo $mail-&amp;gt;ErrorInfo;//如果发送失败，则返回错误提示
		}&lt;/p&gt;

&lt;p&gt;完成用户注册完成后，要通过邮箱验证。如果用户密码忘了，可以通过邮箱找回密码
create table ci_user1(
            id int primary key auto_increment,
            username   varchar(32) not null comment ‘用户的名称’,
            password   char(32) not null comment ‘用户的密码’,
            active  tinyint  not null default 0  comment ‘激活的标志，0表示没有激活，1表示已经激活’,
            validate varchar(32) not null comment ‘激活的用户的校验码’,
            question varchar(32) not null comment ‘问题的名称’,
            answer varchar(32) not null comment ‘问题的答案’
)
完成用户注册，找回密码案例&lt;/p&gt;</content><summary type="html">知识点：邮件相关的协议：
smtp：发邮件，端口：25
pop3：收邮件，端口：110</summary></entry><entry><title type="html">Memcache</title><link href="http://localhost:4000/jekyll/update/2015/10/27/Memcache.html" rel="alternate" type="text/html" title="Memcache" /><published>2015-10-27T16:46:13+08:00</published><updated>2015-10-27T16:46:13+08:00</updated><id>http://localhost:4000/jekyll/update/2015/10/27/Memcache</id><content type="html" xml:base="http://localhost:4000/jekyll/update/2015/10/27/Memcache.html">&lt;p&gt;一、memcache基本的介绍
是一个高性能的分布式内存对象缓存系统。&lt;/p&gt;

&lt;p&gt;和mysql比较，进行理解memcache
（1）该软件是一个c/s架构，
（2）mysql的数据是存储到哪里的？是存储到磁盘里面的。
memcache的数据是存储到内存里面。
（3）mysql的数据存储是，由数据库，数据表，数据的记录，存储数据是按照表的结构进行存储的。
memcache的数据存储格式是：key/value的格式，来存储的，相当于在内存里面有一张两列的哈希表。类似于php的里面的关联数组
key (键名)       值
二、基本的原理：&lt;/p&gt;

&lt;p&gt;比如有一个查询系统，查询某个学生的信息：&lt;/p&gt;

&lt;p&gt;三、安装软件
（1）准备软件，为了方便管理，把该文件拷贝到和apache或mysql或php同一级目录下面。&lt;/p&gt;

&lt;p&gt;（2）开始安装：
把该软件安装成windows的一个服务，便于管理。
步骤：
以管理员的方式，打开cmd（命令提示符）,进入到 memcached文件所在的目录。
可以使用memcahced.exe –h  查看帮助命令。
memcache –d install  开始安装：&lt;/p&gt;

&lt;p&gt;安装完成后，要完成启动该服务，
memcached –d start&lt;/p&gt;

&lt;p&gt;查看是否启动成功，可以通过计算机管理里面的服务选项查看。&lt;/p&gt;

&lt;p&gt;memcache的默认端口号是11211,可以通过查看端口，来判断是否开启该服务，
通过使用netstat –an命令，来查看当前计算机里面监听的服务。&lt;/p&gt;

&lt;p&gt;memcached –d stop停止memcache的服务。&lt;/p&gt;

&lt;p&gt;（3）在安装时，对应的一些参数设置。
比如设置，缓存的大小。
-p 监听的端口
-l 连接的IP地址, 默认是本机
-d start 启动memcached服务
-d restart 重起memcached服务
-d stop|shutdown 关闭正在运行的memcached服务
-d install 安装memcached服务
-d uninstall 卸载memcached服务
-u 以的身份运行 (仅在以root运行的时候有效) 
-m 最大内存使用，单位MB。默认64MB 
-M 内存耗尽时返回错误，而不是删除项
-c 最大同时连接数，默认是1024 
-f 块大小增长因子，默认是1.25 
-n 最小分配空间，key+value+flags默认是48 
-h 显示帮助
-v  输出警告和错误信息。
-vv 打印客户端的请求和返回信息
-i 打印memcached和libevent的版权信息
四、软件操作
1、直接使用telnet远程协议连接，（类似于mysql客户端的黑窗口）（了解）
打开cmd进行输入：
Telnet ip地址（域名）端口号
（1）设置数据，向memcache里面添加数据
添加数据：
语法:
add   键名 0|1（是否压缩）缓存周期值的长度   [按回车，进行输入要添加的数据]
0表示不压缩，1表示要压缩
缓存周期：单位是秒，
值的长度：长度的单位和客户端有关，此处是字节。&lt;/p&gt;

&lt;p&gt;注意：如果键已经存在，则添加失败。&lt;/p&gt;

&lt;p&gt;修改数据：
replace 
语法格式和add是一样的。&lt;/p&gt;

&lt;p&gt;注意：如果键不存在，则修改失败，只能修改已经存在的键。&lt;/p&gt;

&lt;p&gt;设置数据：
set命令和add的语法是一样的。
如果使用set命令，如果键已经存在，则是完成修改，如果键不存在则是添加操作。&lt;/p&gt;

&lt;p&gt;（2）获取数据
get 键名
（3）删除数据
delete 键名&lt;/p&gt;

&lt;p&gt;flush_all  清空所有的数据，
可以设置某一个有效期，
flush_all  秒数，在多少秒之后，清空所有的键。
（4）数据追加
append 在原有值的后面追加数据&lt;/p&gt;

&lt;p&gt;preappend 在原有值的前面追加数据。
（5）查看当前状态的一个命令：
通过该stats 命令能够获取，执行了多少次的get查询，有多少次能够使用get查询到数据，有多少次能够使用get查询失败，计算命中率，
计算命中率  get成功查询的次数/get的总的查询次数，通过命中率来判断memcache服务性能。&lt;/p&gt;

&lt;p&gt;2、使用php程序当成客户端，连接memcache
要安装memcache的扩展。
（1）要准备memcache     php的扩展，在安装扩展时，要和php的版本一致。&lt;/p&gt;

&lt;p&gt;（2）把对应的扩展拷贝到到php安装目录ext目录里面。&lt;/p&gt;

&lt;p&gt;（3）打开php.ini文件，要开启该扩展，完成后，要重启apache,&lt;/p&gt;

&lt;p&gt;（4）测试，是否安装扩展成功，使用phpinfo();函数&lt;/p&gt;

&lt;p&gt;3、php操作memcache.
（1）实例化一个对象。
$mem = new Memcache();
（2）连接memcache,使用connect函数。
  $mem-&amp;gt;connect(主机名，端口号)
  $mem-&amp;gt;add/set(键名，值，是否压缩，缓存时间)
  $mem-&amp;gt;get(键名)&lt;/p&gt;

&lt;p&gt;（3）对存储的数据类型进行讨论。&lt;/p&gt;

&lt;p&gt;php的数据类型：标量数据类型的存储方式。&lt;/p&gt;

&lt;p&gt;php的标量类型在memcache里面存储都是转换成字符串的形式来存储的。&lt;/p&gt;

&lt;p&gt;php的数据类型：数组的形式。&lt;/p&gt;

&lt;p&gt;在存储数组时，把数组序列化之后，存储到 memcache里面的，在取出数组数据时，自动给我们反序列化。数组的序列化和反序列化，是有add和get函数完成的，无需我们自己干预。&lt;/p&gt;

&lt;p&gt;4、入门案例的使用。
根据一个sql取出的数据，把sql取出的数据，给缓存到memcache里面，当下次再操作该sql语句的时候，则直接从memcache里面获取。&lt;/p&gt;

&lt;p&gt;七、memcache细节讨论
1、缓存周期（有效期）
缓存周期的设置有两种方式：
如果缓存周期设置为0表明此数据永不过期
第一种使用：秒数，最大不能超过30天，即2592000秒，
第二种使用：使用时间戳，该时间戳是到的哪个时间点。比如我们要把一个数据缓存60天，
$mem-&amp;gt;add($key,$value,0,time()+60&lt;em&gt;24&lt;/em&gt;3600)
2、惰性删除，
就是说，缓存的数据，到期后，不会自动删除，当get数据的时候，查看有没有到期，如果到期了，则再删除该数据。
memcache不会开启进程来监视键是否过期，省memcache的资源，也省cpu.
3、Least Recently Used（LRU）
最近最少使用原则，
当前存储的数据的在memcache里面空间已经占满后，则memcache会把不活跃（get或set次数比较少的）的数据（不管是否到期）清除，让新的数据给存储进来。
4、安全性
memcache定位就是做数据的缓存的，不是数据的持久存储的，因此没有做一些用户的验证，目的提高连接速度，发挥自己的独特功能。&lt;/p&gt;

&lt;p&gt;memcahe该软件本身没有提供一些安全机制，如果要限制使用，则只能在操作系统的层面来解决，比如window系统、安装防火墙的软件，在linux下面使用iptables,seclinux(安全机制)&lt;/p&gt;

&lt;p&gt;5、memcache比较适合于存储哪些数据。
存储的数据的特点：
访问比较频繁，
安全性不高，丢失无所谓，
修改比较频繁的数据，比如一些用户的在线状态，&lt;/p&gt;</content><summary type="html">一、memcache基本的介绍
是一个高性能的分布式内存对象缓存系统。</summary></entry><entry><title type="html">jquery</title><link href="http://localhost:4000/jekyll/update/2015/04/27/jquery.html" rel="alternate" type="text/html" title="jquery" /><published>2015-04-27T20:43:05+08:00</published><updated>2015-04-27T20:43:05+08:00</updated><id>http://localhost:4000/jekyll/update/2015/04/27/jquery</id><content type="html" xml:base="http://localhost:4000/jekyll/update/2015/04/27/jquery.html">&lt;p&gt;jquery教程 : http://www.w3school.com.cn/jquery/&lt;/p&gt;

&lt;p&gt;JQuery的用途和功能 
    一、取得页面中的元素。
        如果不使用JavaScript库，遍历DOM树，以及查找HTML文档结构中某个特殊的部分，必需编写很多代码。jQuery为准确获取需要操纵的文档元素，提供了可靠而富有效率的选择符机制。
    二、修改页面的外观。
        CSS虽然为呈现方式提供了一种强大的手段，但当所有浏览器不完全支持相同的标准时，单纯使用CSS就会显得力不从心。jQuery可以弥补这一不足，它提供了跨浏览器的标准来解决方案。而且即使在页面已经呈现之后，jQuery仍然能够改变文档中某个部分的类或都个别的样式属性。
    三、改变页面的内容。
        jQuery能够影响的范围并不局限于简单的外观变化，使用少量的代码，jQuery就能改变文档的内容，可以改变文本、插入或都翻转图像、对列表重新排序，甚至对HTML文档的整个结构都能重写和扩充——所有这些只需要一个简单易用的API。
    四、响应用户的页面操作。
    即使是最强大和最精心的设计的行为，如果我们无法控制它何时发生，那它也毫无用处。jQuery提供了截取形形色色的页面事件（比如用户单击一个链接）的适当方式，而不需要使用事件处理程序搞乱HTML代码。此外，它的事件处理API也消除了经常困扰Web开发人员的浏览器不一致性。
    五、为页面添加动态效果。
        为了实现某种交互式行为，设计者也必须向用户提供视觉上的反馈。jQuery中内置的一批淡入、擦除之类的效果，以及制作新效果的工具包，为此提供了便利。
    六、无需刷新页面。
        即可从服务器获取信息，这种编程模式就是从所周知的AJAX（Asyynchoronous JavaScript and XML），它能辅助Web开发人员创建出反应灵敏、功能丰富的网站。jQuery通过消除这一过程中的浏览器特定的复杂性，使开发人员得以专注于服务器端的功能设计。
    七、简化常见的JavaScript任务。
        除了这些完全针对文档的特性之外，jQuery也提供了对基本的JavaScript结构（例如迭代和数组操作等）的增强。&lt;/p&gt;

&lt;p&gt;jQuery 选择器
	选择器 	实例 	选取
	* 	$(“*”) 	所有元素
	#id 	$(“#lastname”) 	id=”lastname” 的元素
	.class 	$(“.intro”) 	所有 class=”intro” 的元素
	element 	$(“p”) 	所有 &amp;lt;p&amp;gt; 元素
	.class.class 	$(“.intro.demo”) 	所有 class=”intro” 且 class=”demo” 的元素&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;:first 	$(&quot;p:first&quot;) 	第一个 &amp;lt;p&amp;gt; 元素
:last 	$(&quot;p:last&quot;) 	最后一个 &amp;lt;p&amp;gt; 元素
:even 	$(&quot;tr:even&quot;) 	所有偶数 &amp;lt;tr&amp;gt; 元素
:odd 	$(&quot;tr:odd&quot;) 	所有奇数 &amp;lt;tr&amp;gt; 元素
		 
:eq(index) 	$(&quot;ul li:eq(3)&quot;) 	列表中的第四个元素（index 从 0 开始）
:gt(no) 	$(&quot;ul li:gt(3)&quot;) 	列出 index 大于 3 的元素
:lt(no) 	$(&quot;ul li:lt(3)&quot;) 	列出 index 小于 3 的元素
:not(selector) 	$(&quot;input:not(:empty)&quot;) 	所有不为空的 input 元素
		 
:header 	$(&quot;:header&quot;) 	所有标题元素 &amp;lt;h1&amp;gt; - &amp;lt;h6&amp;gt;
:animated 	  	所有动画元素
		 
:contains(text) 	$(&quot;:contains('W3School')&quot;) 	包含指定字符串的所有元素
:empty 	$(&quot;:empty&quot;) 	无子（元素）节点的所有元素
:hidden 	$(&quot;p:hidden&quot;) 	所有隐藏的 &amp;lt;p&amp;gt; 元素
:visible 	$(&quot;table:visible&quot;) 	所有可见的表格
		 
s1,s2,s3 	$(&quot;th,td,.intro&quot;) 	所有带有匹配选择的元素
		 
[attribute] 	$(&quot;[href]&quot;) 	所有带有 href 属性的元素
[attribute=value] 	$(&quot;[href='#']&quot;) 	所有 href 属性的值等于 &quot;#&quot; 的元素
[attribute!=value] 	$(&quot;[href!='#']&quot;) 	所有 href 属性的值不等于 &quot;#&quot; 的元素
[attribute$=value] 	$(&quot;[href$='.jpg']&quot;) 	所有 href 属性的值包含以 &quot;.jpg&quot; 结尾的元素
		 
:input 	$(&quot;:input&quot;) 	所有 &amp;lt;input&amp;gt; 元素
:text 	$(&quot;:text&quot;) 	所有 type=&quot;text&quot; 的 &amp;lt;input&amp;gt; 元素
:password 	$(&quot;:password&quot;) 	所有 type=&quot;password&quot; 的 &amp;lt;input&amp;gt; 元素
:radio 	$(&quot;:radio&quot;) 	所有 type=&quot;radio&quot; 的 &amp;lt;input&amp;gt; 元素
:checkbox 	$(&quot;:checkbox&quot;) 	所有 type=&quot;checkbox&quot; 的 &amp;lt;input&amp;gt; 元素
:submit 	$(&quot;:submit&quot;) 	所有 type=&quot;submit&quot; 的 &amp;lt;input&amp;gt; 元素
:reset 	$(&quot;:reset&quot;) 	所有 type=&quot;reset&quot; 的 &amp;lt;input&amp;gt; 元素
:button 	$(&quot;:button&quot;) 	所有 type=&quot;button&quot; 的 &amp;lt;input&amp;gt; 元素
:image 	$(&quot;:image&quot;) 	所有 type=&quot;image&quot; 的 &amp;lt;input&amp;gt; 元素
:file 	$(&quot;:file&quot;) 	所有 type=&quot;file&quot; 的 &amp;lt;input&amp;gt; 元素
		 
:enabled 	$(&quot;:enabled&quot;) 	所有激活的 input 元素
:disabled 	$(&quot;:disabled&quot;) 	所有禁用的 input 元素
:selected 	$(&quot;:selected&quot;) 	所有被选取的 input 元素
:checked 	$(&quot;:checked&quot;) 	所有被选中的 input 元素
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;元素事件列表说明
	注：不带参数的函数，其参数为可选的 fn。jQuery不支持form元素的reset事件。
	事件 描述 支持元素或对象
	blur( ) 元素失去焦点 a, input, textarea, button, select, label, map, area
	change( ) 用户改变域的内容 input, textarea, select
	click( ) 鼠标点击某个对象 几乎所有元素
	dblclick( ) 鼠标双击某个对象 几乎所有元素
	error( ) 当加载文档或图像时发生某个错误 window, img
	focus( ) 元素获得焦点 a, input, textarea, button, select, label, map, area
	keydown( ) 某个键盘的键被按下 几乎所有元素
	keypress( ) 某个键盘的键被按下或按住 几乎所有元素
	keyup( ) 某个键盘的键被松开 几乎所有元素
	load( fn ) 某个页面或图像被完成加载 window, img
	mousedown( fn ) 某个鼠标按键被按下 几乎所有元素
	mousemove( fn ) 鼠标被移动 几乎所有元素
	mouseout( fn ) 鼠标从某元素移开 几乎所有元素
	mouseover( fn ) 鼠标被移到某元素之上 几乎所有元素
	mouseup( fn ) 某个鼠标按键被松开 几乎所有元素
	resize( fn ) 窗口或框架被调整尺寸 window, iframe, frame
	scroll( fn ) 滚动文档的可视部分时 window
	select( ) 文本被选定 document, input, textarea
	submit( ) 提交按钮被点击 form
	unload( fn ) 用户退出页面 window&lt;/p&gt;

&lt;p&gt;获取值:
	文本框,文本区域:$(“#txt”).attr(“value”);
	多选框checkbox:$(“input[name=’checkbox’:checked]”).each(function(){
	var val = $(this).val();
	});
	单选组radio: $(“input[type=radio][checked]”).val();
	下拉框select的value值: $(‘select’).val();
	下拉框select选中的text 值:$(“select”).find(“option:selected”).text();
	控制表单元素:
	文本框,文本区域:$(“#txt”).attr(“value”,”); //清空内容
	$(“#txt”).attr(“value”,’11′); //填充内容
  jQuery获取Radio选择的Value值&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$(&quot;input[name='radio_name'][checked]&quot;).val(); //选择被选中Radio的Value值
$(&quot;#text_id&quot;).focus(function(){//code...}); //事件 当对象text_id获取焦点时触发
$(&quot;#text_id&quot;).blur(function(){//code...}); //事件 当对象text_id失去焦点时触发
$(&quot;#text_id&quot;).select(); //使文本框的Vlaue值成选中状态
$(&quot;input[name='radio_name'][value='要选中Radio的Value值'&quot;).
attr(&quot;checked&quot;,true); //根据Value值设置Radio为选中状态
jQuery获取CheckBox选择的Value值
$(&quot;input[name='checkbox_name'][checked]&quot;); //选择被选中CheckBox元素的集合 如果你想得到
    Value值你需要遍历这个集合
$($(&quot;input[name='checkbox_name'][checked]&quot;)).
each(function(){arrChk+=this.value + ',';});//遍历被选中CheckBox元素的集合 得到Value值
$(&quot;#checkbox_id&quot;).attr(&quot;checked&quot;); //获取一个CheckBox的状态(有没有被选中,返回true/false)
$(&quot;#checkbox_id&quot;).attr(&quot;checked&quot;,true); //设置一个CheckBox的状态为选中(checked=true)
$(&quot;#checkbox_id&quot;).attr(&quot;checked&quot;,false); //设置一个CheckBox的状态为不选中(checked=false)
$(&quot;input[name='checkbox_name']&quot;).attr
(&quot;checked&quot;,$(&quot;#checkbox_id&quot;).attr(&quot;checked&quot;));//根据3,4,5条,你可以分析分析这句代码的意思
$(&quot;#text_id&quot;).val().split(&quot;,&quot;); //将Text的Value值以','分隔 返回一个数组

jquery给input赋值val(val)  
  
val(val)是jquery函数，最容易混淆的是获取input的函数是val()；  
  
区别非常小，一个是带参数，一个是不带参数；  
  
&amp;lt;input name=&quot;user&quot; class=&quot;txtshort&quot; id=&quot;user&quot; value=&quot;输入手机号码或邮箱&quot; /&amp;gt;  
  
$(&quot;#user&quot;).val(&quot;&quot;); 清空ID为user的值；  
  
以下是一段常用的在登录时在文本框内用文字提示用户输入的代码  
  
$(document).ready(function() {  
  
$(&quot;#user&quot;).addClass('phplike_blur');  
  
$(&quot;#password&quot;).addClass('phplike_focus');  //添加样式，如果无，可以不写  
  
$(&quot;#user&quot;).focus(function(){ $(this).removeClass('phplike_blur');  
  
if ($(&quot;#user&quot;).val() == '输入手机号码或邮箱')  //如果值为提示信息，获得焦点时，清空提示信息，样式说明在此省略  
  
{  
  
$(this).addClass('phplike_focus');$(&quot;#user&quot;).val(&quot;&quot;);  
  
}  
  
else { $(this).removeClass('phplike_blur'); }  
  
}) $(&quot;#user&quot;).blur(function(){  
  
if ($(&quot;#user&quot;).val() == '') //失去焦点时，如果文本框内容为空，则显示提示信息  
  
{ $(&quot;#user&quot;).val(&quot;输入手机号码或邮箱&quot;);  
  
$(this).addClass('phplike_blur'); }  
  
})  
  
})  
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;</content><summary type="html">jquery教程 : http://www.w3school.com.cn/jquery/</summary></entry></feed>
